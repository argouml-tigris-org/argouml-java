<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GeneratorJava.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">argo_java</a> &gt; <a href="index.source.html" class="el_package">org.argouml.language.java.generator</a> &gt; <span class="el_source">GeneratorJava.java</span></div><h1>GeneratorJava.java</h1><pre class="source lang-java linenums">/* $Id$
 *****************************************************************************
 * Copyright (c) 2009-2013 Contributors - see below
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Thomas Neustupny
 *****************************************************************************
 *
 * Some portions of this file was previously release using the BSD License:
 */

// Copyright (c) 1996-2008 The Regents of the University of California. All
// Rights Reserved. Permission to use, copy, modify, and distribute this
// software and its documentation without fee, and without a written
// agreement is hereby granted, provided that the above copyright notice
// and this paragraph appear in all copies.  This software program and
// documentation are copyrighted by The Regents of the University of
// California. The software program and documentation are supplied &quot;AS
// IS&quot;, without any accompanying services from The Regents. The Regents
// does not warrant that the operation of the program will be
// uninterrupted or error-free. The end-user understands that the program
// was developed for research purposes and is advised not to rely
// exclusively on the program for any reason.  IN NO EVENT SHALL THE
// UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
// SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS,
// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE. THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY
// WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
// PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS, AND THE UNIVERSITY OF
// CALIFORNIA HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE, SUPPORT,
// UPDATES, ENHANCEMENTS, OR MODIFICATIONS.

package org.argouml.language.java.generator;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;
import java.util.StringTokenizer;
import java.util.logging.Level;
import java.util.logging.Logger;

import org.argouml.application.api.Argo;
import org.argouml.application.helpers.ResourceLoaderWrapper;
import org.argouml.configuration.Configuration;
import org.argouml.language.java.JavaModuleGlobals;
import org.argouml.model.Model;
import org.argouml.moduleloader.ModuleInterface;
import org.argouml.ocl.ArgoFacade;
import org.argouml.uml.DocumentationManager;
import org.argouml.uml.generator.CodeGenerator;
import org.argouml.uml.generator.GeneratorHelper;
import org.argouml.uml.generator.GeneratorManager;
import org.argouml.uml.generator.Language;
import org.argouml.uml.generator.TempFileUtils;
import org.argouml.uml.reveng.ImportInterface;

import tudresden.ocl.OclTree;
import tudresden.ocl.parser.analysis.DepthFirstAdapter;
import tudresden.ocl.parser.node.AConstraintBody;

/**
 * FileGenerator implementing class to generate Java for display in diagrams and
 * in text fields in the ArgoUML user interface.
 */
<span class="fc" id="L81">public class GeneratorJava implements CodeGenerator, ModuleInterface {</span>

    /**
     * Logger.
     */
<span class="fc" id="L86">    private static final Logger LOG =</span>
<span class="fc" id="L87">        Logger.getLogger(GeneratorJava.class.getName());</span>

    private boolean verboseDocs;

    private boolean lfBeforeCurly;

    private static final boolean VERBOSE_DOCS = false;

<span class="fc" id="L95">    private static final String LINE_SEPARATOR = System</span>
<span class="fc" id="L96">            .getProperty(&quot;line.separator&quot;);</span>

    private static final String LANG_PACKAGE = &quot;java.lang&quot;;

    private static final Set&lt;String&gt; JAVA_TYPES;
    static {
<span class="fc" id="L102">        Set&lt;String&gt; types = new HashSet&lt;String&gt;();</span>
<span class="fc" id="L103">        types.add(&quot;void&quot;);</span>
<span class="fc" id="L104">        types.add(&quot;boolean&quot;);</span>
<span class="fc" id="L105">        types.add(&quot;byte&quot;);</span>
<span class="fc" id="L106">        types.add(&quot;char&quot;);</span>
<span class="fc" id="L107">        types.add(&quot;int&quot;);</span>
<span class="fc" id="L108">        types.add(&quot;short&quot;);</span>
<span class="fc" id="L109">        types.add(&quot;long&quot;);</span>
<span class="fc" id="L110">        types.add(&quot;float&quot;);</span>
<span class="fc" id="L111">        types.add(&quot;double&quot;);</span>
<span class="fc" id="L112">        JAVA_TYPES = Collections.unmodifiableSet(types);</span>
    }

    // TODO: make it configurable
    // next two flags shows in what mode we are working
    /**
     * &lt;code&gt;true&lt;/code&gt; when GenerateFile.
     */
    private static boolean isFileGeneration;

    /**
     * &lt;code&gt;true&lt;/code&gt; if GenerateFile in Update Mode.
     */
    private static boolean isInUpdateMode;

    /**
     * Two spaces used for indenting code in classes.
     */
    private static final String INDENT = &quot;  &quot;;

    /**
     * The Language instance.
     */
<span class="fc" id="L135">    private static Language java = GeneratorHelper.makeLanguage(&quot;Java&quot;, &quot;Java&quot;,</span>
<span class="fc" id="L136">            ResourceLoaderWrapper.lookupIconResource(&quot;JavaNotation&quot;));</span>

    /**
     * Generates a file for the classifier. This method could have been static
     * if it where not for the need to call it through the Generatorinterface.
     * Returns the full path name of the the generated file or null if no file
     * can be generated.
     * 
     * @param modelElement the element to be generated
     * @param path the path where the element will be generated
     * @return String full path name of the the generated file
     */
    private String generateFile(Object modelElement, String path) {
<span class="nc" id="L149">        String name = Model.getFacade().getName(modelElement);</span>
<span class="nc bnc" id="L150" title="All 4 branches missed.">        if (name == null || name.length() == 0) {</span>
<span class="nc" id="L151">            return null;</span>
        }
<span class="nc" id="L153">        Object classifier = modelElement;</span>
<span class="nc" id="L154">        String filename = name + &quot;.java&quot;;</span>
<span class="nc" id="L155">        StringBuilder sbPath = new StringBuilder(path);</span>
<span class="nc bnc" id="L156" title="All 2 branches missed.">        if (!path.endsWith(FILE_SEPARATOR)) {</span>
<span class="nc" id="L157">            sbPath.append(FILE_SEPARATOR);</span>
        }

<span class="nc" id="L160">        String packagePath = getPackageName(Model.getFacade().getNamespace(</span>
                classifier));

<span class="nc" id="L163">        int lastIndex = -1;</span>
        do {
<span class="nc" id="L165">            File f = new File(sbPath.toString());</span>
<span class="nc bnc" id="L166" title="All 4 branches missed.">            if (!f.isDirectory() &amp;&amp; !f.mkdir()) {</span>
<span class="nc" id="L167">                LOG.severe(&quot; could not make directory &quot; + path);</span>
<span class="nc" id="L168">                return null;</span>
            }

<span class="nc bnc" id="L171" title="All 2 branches missed.">            if (lastIndex == packagePath.length()) {</span>
<span class="nc" id="L172">                break;</span>
            }

<span class="nc" id="L175">            int index = packagePath.indexOf(&quot;.&quot;, lastIndex + 1);</span>
<span class="nc bnc" id="L176" title="All 2 branches missed.">            if (index == -1) {</span>
<span class="nc" id="L177">                index = packagePath.length();</span>
            }

<span class="nc" id="L180">            sbPath.append(packagePath.substring(lastIndex + 1, index)</span>
                    + FILE_SEPARATOR);
<span class="nc" id="L182">            lastIndex = index;</span>
<span class="nc" id="L183">        } while (true);</span>

<span class="nc" id="L185">        String pathname = sbPath.toString() + filename;</span>
        // cat.info(&quot;-----&quot; + pathname + &quot;-----&quot;);

        // now decide whether file exist and need an update or is to be
        // newly generated
<span class="nc" id="L190">        File f = new File(pathname);</span>
<span class="nc" id="L191">        isFileGeneration = true; // used to produce method javadoc</span>

        // String pathname = path + filename;
        // TODO: package, project basepath, tagged values to configure
<span class="nc" id="L195">        LOG.info(&quot;Generating &quot; + f.getPath());</span>
<span class="nc" id="L196">        isFileGeneration = true;</span>
<span class="nc" id="L197">        String header = generateHeader(classifier, pathname, packagePath);</span>
<span class="nc" id="L198">        String src = generateClassifier(classifier);</span>
<span class="nc" id="L199">        BufferedWriter fos = null;</span>
        try {
<span class="nc bnc" id="L201" title="All 2 branches missed.">            if (Configuration.getString(Argo.KEY_INPUT_SOURCE_ENCODING) == null</span>
<span class="nc" id="L202">                    || Configuration.getString(Argo.KEY_INPUT_SOURCE_ENCODING)</span>
<span class="nc bnc" id="L203" title="All 2 branches missed.">                            .trim().equals(&quot;&quot;)) {</span>
<span class="nc" id="L204">                fos = new BufferedWriter(new OutputStreamWriter(</span>
                        new FileOutputStream(f),
<span class="nc" id="L206">                        System.getProperty(&quot;file.encoding&quot;)));</span>
            } else {
<span class="nc" id="L208">                fos = new BufferedWriter(</span>
                        new OutputStreamWriter(
                                new FileOutputStream(f),
<span class="nc" id="L211">                                Configuration.getString(</span>
                                        Argo.KEY_INPUT_SOURCE_ENCODING)));
            }
<span class="nc" id="L214">            fos.write(header);</span>
<span class="nc" id="L215">            fos.write(src);</span>
<span class="nc" id="L216">        } catch (IOException exp) {</span>
<span class="nc" id="L217">            LOG.severe(&quot;IO Exception: &quot; + exp + &quot;, for file: &quot; + f.getPath());</span>
        } finally {
<span class="nc" id="L219">            isFileGeneration = false;</span>
            try {
<span class="nc bnc" id="L221" title="All 2 branches missed.">                if (fos != null) {</span>
<span class="nc" id="L222">                    fos.close();</span>
                }
<span class="nc" id="L224">            } catch (IOException exp) {</span>
<span class="nc" id="L225">                LOG.severe(&quot;FAILED: &quot; + f.getPath());</span>
<span class="nc" id="L226">            }</span>
        }

        // cat.info(&quot;----- end updating -----&quot;);
<span class="nc" id="L230">        return pathname;</span>
    }

    private String generateHeader(Object cls, String pathname,
            String packagePath) {
<span class="nc" id="L235">        StringBuffer sb = new StringBuffer(80);</span>
        // TODO: add user-defined copyright
        if (VERBOSE_DOCS) {
            sb.append(&quot;// FILE: &quot;).append(pathname.replace('\\', '/'));
            sb.append(LINE_SEPARATOR).append(LINE_SEPARATOR);
        }
<span class="nc bnc" id="L241" title="All 2 branches missed.">        if (packagePath.length() &gt; 0) {</span>
<span class="nc" id="L242">            sb.append(&quot;package &quot;).append(packagePath).append(&quot;;&quot;);</span>
<span class="nc" id="L243">            sb.append(LINE_SEPARATOR).append(LINE_SEPARATOR);</span>
        }
<span class="nc" id="L245">        sb.append(generateImports(cls, packagePath));</span>
<span class="nc" id="L246">        return sb.toString();</span>
    }

    /**
     * Generates code for some modelelement. Subclasses should implement this to
     * generate code for different notations.
     * 
     * @param o the element to be generated
     * @return String the generated code
     */
    private String generate(Object o) {
<span class="nc bnc" id="L257" title="All 2 branches missed.">        if (o == null) {</span>
<span class="nc" id="L258">            return &quot;&quot;;</span>
        }
<span class="nc bnc" id="L260" title="All 2 branches missed.">        if (Model.getFacade().isAActionState(o)) {</span>
<span class="nc" id="L261">            return generateActionState(o);</span>
        }
<span class="nc bnc" id="L263" title="All 2 branches missed.">        if (Model.getFacade().isAExtensionPoint(o)) {</span>
<span class="nc" id="L264">            return generateExtensionPoint(o);</span>
        }
<span class="nc bnc" id="L266" title="All 2 branches missed.">        if (Model.getFacade().isAOperation(o)) {</span>
<span class="nc" id="L267">            return generateOperation(o, false);</span>
        }
<span class="nc bnc" id="L269" title="All 2 branches missed.">        if (Model.getFacade().isAAttribute(o)) {</span>
<span class="nc" id="L270">            return generateAttribute(o, false);</span>
        }
<span class="nc bnc" id="L272" title="All 2 branches missed.">        if (Model.getFacade().isAParameter(o)) {</span>
<span class="nc" id="L273">            return generateParameter(o);</span>
        }
<span class="nc bnc" id="L275" title="All 2 branches missed.">        if (Model.getFacade().isAPackage(o)) {</span>
<span class="nc" id="L276">            return generatePackage(o);</span>
        }
<span class="nc bnc" id="L278" title="All 2 branches missed.">        if (Model.getFacade().isAClassifier(o)) {</span>
<span class="nc" id="L279">            return generateClassifier(o);</span>
        }
<span class="nc bnc" id="L281" title="All 2 branches missed.">        if (Model.getFacade().isAExpression(o)) {</span>
<span class="nc" id="L282">            return generateExpression(o);</span>
        }
<span class="nc bnc" id="L284" title="All 2 branches missed.">        if (o instanceof String) {</span>
<span class="nc" id="L285">            return generateName((String) o);</span>
        }
<span class="nc bnc" id="L287" title="All 2 branches missed.">        if (o instanceof String) {</span>
<span class="nc" id="L288">            return generateUninterpreted((String) o);</span>
        }
<span class="nc bnc" id="L290" title="All 2 branches missed.">        if (Model.getFacade().isAStereotype(o)) {</span>
<span class="nc" id="L291">            return generateStereotype(o);</span>
        }
<span class="nc bnc" id="L293" title="All 2 branches missed.">        if (Model.getFacade().isATaggedValue(o)) {</span>
<span class="nc" id="L294">            return generateTaggedValue(o);</span>
        }
<span class="nc bnc" id="L296" title="All 2 branches missed.">        if (Model.getFacade().isAAssociationEnd(o)) {</span>
<span class="nc" id="L297">            return generateAssociationEnd(o);</span>
        }
<span class="nc bnc" id="L299" title="All 2 branches missed.">        if (Model.getFacade().isAMultiplicity(o)) {</span>
<span class="nc" id="L300">            return generateMultiplicity(o);</span>
        }
<span class="nc bnc" id="L302" title="All 2 branches missed.">        if (Model.getFacade().isAState(o)) {</span>
<span class="nc" id="L303">            return generateState(o);</span>
        }
<span class="nc bnc" id="L305" title="All 2 branches missed.">        if (Model.getFacade().isATransition(o)) {</span>
<span class="nc" id="L306">            return generateTransition(o);</span>
        }
<span class="nc bnc" id="L308" title="All 2 branches missed.">        if (Model.getFacade().isAAction(o)) {</span>
<span class="nc" id="L309">            return generateAction(o);</span>
        }
<span class="nc bnc" id="L311" title="All 2 branches missed.">        if (Model.getFacade().isACallAction(o)) {</span>
<span class="nc" id="L312">            return generateAction(o);</span>
        }
<span class="nc bnc" id="L314" title="All 2 branches missed.">        if (Model.getFacade().isAGuard(o)) {</span>
<span class="nc" id="L315">            return generateGuard(o);</span>
        }
<span class="nc bnc" id="L317" title="All 2 branches missed.">        if (Model.getFacade().isAMessage(o)) {</span>
<span class="nc" id="L318">            return generateMessage(o);</span>
        }
<span class="nc bnc" id="L320" title="All 2 branches missed.">        if (Model.getFacade().isAEvent(o)) {</span>
<span class="nc" id="L321">            return generateEvent(o);</span>
        }
<span class="nc bnc" id="L323" title="All 2 branches missed.">        if (Model.getFacade().isAVisibilityKind(o)) {</span>
<span class="nc" id="L324">            return generateVisibility(o);</span>
        }

<span class="nc bnc" id="L327" title="All 2 branches missed.">        if (Model.getFacade().isAModelElement(o)) {</span>
<span class="nc" id="L328">            return generateName(Model.getFacade().getName(o));</span>
        }

<span class="nc" id="L331">        return o.toString();</span>
    }

    /**
     * Generates the import statements for the class
     * 
     * @param cls The class object
     * @param packagePath The package path
     * @return a string containing the import statements
     */
    private String generateImports(Object cls, String packagePath) {
        // If the model is built by the import of Java source code, then a
        // component named after the filename was created, which manages the
        // import statements for all included classes/interfaces. This
        // component is now searched for cls in order to extract the imports.
<span class="nc" id="L346">        Object ns = Model.getFacade().getNamespace(cls);</span>
<span class="nc bnc" id="L347" title="All 2 branches missed.">        if (ns != null) {</span>
<span class="nc bnc" id="L348" title="All 2 branches missed.">            for (Object oe : Model.getFacade().getOwnedElements(ns)) {</span>
<span class="nc bnc" id="L349" title="All 2 branches missed.">                if (Model.getFacade().getUmlVersion().charAt(0) == '1'</span>
<span class="nc bnc" id="L350" title="All 2 branches missed.">                        &amp;&amp; Model.getFacade().isAComponent(oe)) {</span>
                    for (Object re
<span class="nc bnc" id="L352" title="All 2 branches missed.">                             : Model.getFacade().getResidentElements(oe)) {</span>
<span class="nc" id="L353">                        Object r = Model.getFacade().getResident(re);</span>
<span class="nc bnc" id="L354" title="All 2 branches missed.">                        if (r.equals(cls)) {</span>
<span class="nc" id="L355">                            return generateArtifactImports(oe);</span>
                        }
<span class="nc" id="L357">                    }</span>
<span class="nc bnc" id="L358" title="All 2 branches missed.">                } else if (Model.getFacade().isAArtifact(oe)</span>
<span class="nc" id="L359">                           &amp;&amp; (Model.getCoreHelper().getUtilizedElements(oe)</span>
<span class="nc bnc" id="L360" title="All 2 branches missed.">                               .contains(cls))) {</span>
<span class="nc" id="L361">                    return generateArtifactImports(oe);</span>
                }
<span class="nc" id="L363">            }</span>
        }
        // We now have the situation that no component with package imports
        // was found, so the import statements are guessed from the used model
        // elements inside cls.
<span class="nc" id="L368">        StringBuffer sb = new StringBuffer(80);</span>
<span class="nc" id="L369">        Set&lt;String&gt; importSet = new HashSet&lt;String&gt;();</span>

        // now check packages of all feature types
<span class="nc bnc" id="L372" title="All 2 branches missed.">        for (Object mFeature : Model.getFacade().getFeatures(cls)) {</span>
<span class="nc bnc" id="L373" title="All 2 branches missed.">            if (Model.getFacade().isAAttribute(mFeature)) {</span>
<span class="nc" id="L374">                String ftype = generateImportType(</span>
<span class="nc" id="L375">                        Model.getFacade().getType(mFeature), packagePath);</span>
<span class="nc bnc" id="L376" title="All 2 branches missed.">                if (ftype != null) {</span>
<span class="nc" id="L377">                    importSet.add(ftype);</span>
                }
<span class="nc bnc" id="L379" title="All 2 branches missed.">            } else if (Model.getFacade().isAOperation(mFeature)) {</span>
                // check the parameter types
<span class="nc bnc" id="L381" title="All 2 branches missed.">                for (Object parameter : Model.getFacade().getParameters(</span>
                        mFeature)) {
<span class="nc" id="L383">                    String ftype = generateImportType(Model.getFacade()</span>
<span class="nc" id="L384">                            .getType(parameter), packagePath);</span>
<span class="nc bnc" id="L385" title="All 2 branches missed.">                    if (ftype != null) {</span>
<span class="nc" id="L386">                        importSet.add(ftype);</span>
                    }
<span class="nc" id="L388">                }</span>

                // check the return parameter types
<span class="nc bnc" id="L391" title="All 2 branches missed.">                for (Object parameter : Model.getCoreHelper()</span>
<span class="nc" id="L392">                        .getReturnParameters(mFeature)) {</span>
<span class="nc" id="L393">                    String ftype = generateImportType(Model.getFacade()</span>
<span class="nc" id="L394">                            .getType(parameter), packagePath);</span>
<span class="nc bnc" id="L395" title="All 2 branches missed.">                    if (ftype != null) {</span>
<span class="nc" id="L396">                        importSet.add(ftype);</span>
                    }
<span class="nc" id="L398">                }</span>

                // check raised signals
<span class="nc bnc" id="L401" title="All 2 branches missed.">                for (Object signal : Model.getFacade().getRaisedSignals(</span>
                        mFeature)) {
<span class="nc bnc" id="L403" title="All 2 branches missed.">                    if (!Model.getFacade().isAException(signal)) {</span>
<span class="nc" id="L404">                        continue;</span>
                    }
<span class="nc" id="L406">                    String ftype = generateImportType(Model.getFacade()</span>
<span class="nc" id="L407">                            .getType(signal), packagePath);</span>
<span class="nc bnc" id="L408" title="All 2 branches missed.">                    if (ftype != null) {</span>
<span class="nc" id="L409">                        importSet.add(ftype);</span>
                    }
<span class="nc" id="L411">                }</span>
            }
<span class="nc" id="L413">        }</span>

        // now check generalizations
<span class="nc bnc" id="L416" title="All 2 branches missed.">        for (Object gen : Model.getFacade().getGeneralizations(cls)) {</span>
<span class="nc" id="L417">            Object parent = Model.getFacade().getGeneral(gen);</span>
<span class="nc bnc" id="L418" title="All 2 branches missed.">            if (parent == cls) {</span>
<span class="nc" id="L419">                continue;</span>
            }

<span class="nc" id="L422">            String ftype = generateImportType(parent, packagePath);</span>
<span class="nc bnc" id="L423" title="All 2 branches missed.">            if (ftype != null) {</span>
<span class="nc" id="L424">                importSet.add(ftype);</span>
            }
<span class="nc" id="L426">        }</span>

        // now check packages of the interfaces
<span class="nc bnc" id="L429" title="All 2 branches missed.">        for (Object iface : Model.getFacade().getSpecifications(cls)) {</span>
<span class="nc" id="L430">            String ftype = generateImportType(iface, packagePath);</span>
<span class="nc bnc" id="L431" title="All 2 branches missed.">            if (ftype != null) {</span>
<span class="nc" id="L432">                importSet.add(ftype);</span>
            }
<span class="nc" id="L434">        }</span>

        // check association end types
        for (Object associationEnd
<span class="nc bnc" id="L438" title="All 2 branches missed.">                 : Model.getFacade().getAssociationEnds(cls)) {</span>
<span class="nc" id="L439">            Object association = Model.getFacade().getAssociation(</span>
                    associationEnd);
<span class="nc bnc" id="L441" title="All 2 branches missed.">            for (Object associationEnd2 : Model.getFacade().getConnections(</span>
                    association)) {
<span class="nc bnc" id="L443" title="All 2 branches missed.">                if (associationEnd2 != associationEnd</span>
<span class="nc bnc" id="L444" title="All 2 branches missed.">                        &amp;&amp; Model.getFacade().isNavigable(associationEnd2)</span>
<span class="nc bnc" id="L445" title="All 2 branches missed.">                        &amp;&amp; !Model.getFacade().isAbstract(</span>
<span class="nc" id="L446">                                Model.getFacade().getAssociation(</span>
                                        associationEnd2))) {
                    // association end found
<span class="nc bnc" id="L449" title="All 2 branches missed.">                    if (Model.getFacade().getUpper(associationEnd2) != 1) {</span>
<span class="nc" id="L450">                        importSet.add(&quot;java.util.List&quot;);</span>
                    } else {
<span class="nc" id="L452">                        String ftype = generateImportType(Model.getFacade()</span>
<span class="nc" id="L453">                                .getType(associationEnd2), packagePath);</span>
<span class="nc bnc" id="L454" title="All 2 branches missed.">                        if (ftype != null) {</span>
<span class="nc" id="L455">                            importSet.add(ftype);</span>
                        }
                    }
                }
<span class="nc" id="L459">            }</span>

<span class="nc" id="L461">        }</span>
        // finally generate the import statements
<span class="nc bnc" id="L463" title="All 2 branches missed.">        for (String importType : importSet) {</span>
<span class="nc" id="L464">            sb.append(&quot;import &quot;).append(importType).append(&quot;;&quot;);</span>
<span class="nc" id="L465">            sb.append(LINE_SEPARATOR);</span>
<span class="nc" id="L466">        }</span>
<span class="nc bnc" id="L467" title="All 2 branches missed.">        if (!importSet.isEmpty()) {</span>
<span class="nc" id="L468">            sb.append(LINE_SEPARATOR);</span>
        }
<span class="nc" id="L470">        return sb.toString();</span>
    }

    private String generateArtifactImports(Object artifact) {
<span class="nc" id="L474">        StringBuffer ret = new StringBuffer();</span>
<span class="nc" id="L475">        Object compNamespace = Model.getFacade().getNamespace(artifact);</span>
<span class="nc" id="L476">        boolean found = false;</span>
<span class="nc bnc" id="L477" title="All 2 branches missed.">        for (Object o : Model.getFacade().getClientDependencies(artifact)) {</span>
<span class="nc" id="L478">            boolean isJavaImport = false;</span>
<span class="nc bnc" id="L479" title="All 2 branches missed.">            for (Object stereotype : Model.getFacade().getStereotypes(o)) {</span>
<span class="nc bnc" id="L480" title="All 2 branches missed.">                if (&quot;javaImport&quot;.equals(</span>
<span class="nc" id="L481">                        Model.getFacade().getName(stereotype))) {</span>
<span class="nc" id="L482">                    isJavaImport = true;</span>
<span class="nc" id="L483">                    break;</span>
                }
<span class="nc" id="L485">            }</span>
<span class="nc bnc" id="L486" title="All 2 branches missed.">            if (isJavaImport) {</span>
<span class="nc bnc" id="L487" title="All 2 branches missed.">                for (Object elem : Model.getFacade().getSuppliers(o)) {</span>
<span class="nc" id="L488">                    Object ns = Model.getFacade().getNamespace(elem);</span>
<span class="nc bnc" id="L489" title="All 4 branches missed.">                    if (ns != null &amp;&amp; !ns.equals(compNamespace)) {</span>
<span class="nc" id="L490">                        String packageName = getPackageName(ns);</span>
<span class="nc" id="L491">                        ret.append(&quot;import &quot;);</span>
<span class="nc bnc" id="L492" title="All 4 branches missed.">                        if (packageName != null &amp;&amp; packageName.length() &gt; 0) {</span>
<span class="nc" id="L493">                            ret.append(getPackageName(ns));</span>
<span class="nc" id="L494">                            ret.append('.');</span>
                        }
<span class="nc" id="L496">                        ret.append(Model.getFacade().getName(elem));</span>
<span class="nc bnc" id="L497" title="All 2 branches missed.">                        if (Model.getFacade().isAPackage(elem)) {</span>
<span class="nc" id="L498">                            ret.append(&quot;.*&quot;);</span>
                        }
<span class="nc" id="L500">                        ret.append(&quot;;&quot;);</span>
<span class="nc" id="L501">                        ret.append(LINE_SEPARATOR);</span>
<span class="nc" id="L502">                        found = true;</span>
                    }
<span class="nc" id="L504">                }</span>
            }
<span class="nc" id="L506">        }</span>
<span class="nc bnc" id="L507" title="All 2 branches missed.">        if (found) {</span>
<span class="nc" id="L508">            ret.append(LINE_SEPARATOR);</span>
        }
<span class="nc" id="L510">        return ret.toString();</span>
    }

    private String generateImportType(Object type, String exclude) {
<span class="nc" id="L514">        String ret = null;</span>

<span class="nc bnc" id="L516" title="All 2 branches missed.">        if (Model.getFacade().isADataType(type)</span>
<span class="nc bnc" id="L517" title="All 2 branches missed.">                &amp;&amp; JAVA_TYPES.contains(Model.getFacade().getName(type))) {</span>
<span class="nc" id="L518">            return null;</span>
        }

<span class="nc bnc" id="L521" title="All 4 branches missed.">        if (type != null &amp;&amp; Model.getFacade().getNamespace(type) != null) {</span>
<span class="nc" id="L522">            String p = getPackageName(Model.getFacade().getNamespace(type));</span>
<span class="nc bnc" id="L523" title="All 4 branches missed.">            if (!p.equals(exclude) &amp;&amp; !p.equals(LANG_PACKAGE)) {</span>
<span class="nc bnc" id="L524" title="All 2 branches missed.">                if (p.length() &gt; 0) {</span>
<span class="nc" id="L525">                    ret = p + '.' + Model.getFacade().getName(type);</span>
                } else {
<span class="nc" id="L527">                    ret = Model.getFacade().getName(type);</span>
                }
            }
        }
<span class="nc" id="L531">        return ret;</span>
    }

    /**
     * Generate code for an extension point.
     * &lt;p&gt;
     * 
     * @param ep The extension point to generate for
     * 
     * @return The generated code string. Always empty in this implementation.
     */
    private String generateExtensionPoint(Object ep) {
<span class="nc" id="L543">        return null;</span>
    }

    /**
     * Generate source code for an operation.
     * &lt;p&gt;
     * NOTE: This needs to be package visibility because it is used in
     * OperationCodePiece.
     * 
     * @param op UML Operation to generate code for
     * @param documented flag indicating documentation comments should be
     *            included.
     * @return String containing generated code.
     */
    String generateOperation(Object op, boolean documented) {
<span class="nc bnc" id="L558" title="All 2 branches missed.">        if (isFileGeneration) {</span>
<span class="nc" id="L559">            documented = true; // fix Issue 1506</span>
        }
<span class="nc" id="L561">        StringBuffer sb = new StringBuffer(80);</span>
<span class="nc" id="L562">        String nameStr = null;</span>
<span class="nc" id="L563">        boolean constructor = false;</span>

<span class="nc bnc" id="L565" title="All 2 branches missed.">        if (Model.getExtensionMechanismsHelper().hasStereotype(op, &quot;create&quot;)) {</span>
<span class="nc" id="L566">            nameStr = generateName(Model.getFacade().getName(</span>
<span class="nc" id="L567">                    Model.getFacade().getOwner(op)));</span>
<span class="nc" id="L568">            constructor = true;</span>
        } else {
<span class="nc" id="L570">            nameStr = generateName(Model.getFacade().getName(op));</span>
        }

        // Each pattern here must be similar to corresponding code piece
        // Operation code piece doesn't start with '\n'
        // so the next line is commented. See Issue 1505
        // sb.append(LINE_SEPARATOR); // begin with a blank line
<span class="nc bnc" id="L577" title="All 2 branches missed.">        if (documented) {</span>
<span class="nc" id="L578">            String s = generateConstraintEnrichedDocComment(op, documented,</span>
                    INDENT);
<span class="nc bnc" id="L580" title="All 4 branches missed.">            if (s != null &amp;&amp; s.trim().length() &gt; 0) {</span>
                // should starts as the code piece
<span class="nc" id="L582">                sb.append(s).append(INDENT);</span>
            }
        }

<span class="nc" id="L586">        sb.append(generateVisibility(op));</span>
<span class="nc" id="L587">        sb.append(generateAbstractness(op));</span>
<span class="nc" id="L588">        sb.append(generateScope(op));</span>
<span class="nc" id="L589">        sb.append(generateChangeability(op));</span>
<span class="nc" id="L590">        sb.append(generateConcurrency(op));</span>

        // pick out return type
<span class="nc" id="L593">        Collection returnParams = Model.getCoreHelper().getReturnParameters(op);</span>
        Object rp;
<span class="nc bnc" id="L595" title="All 2 branches missed.">        if (returnParams.size() == 0) {</span>
<span class="nc" id="L596">            rp = null;</span>
        } else {
<span class="nc" id="L598">            rp = returnParams.iterator().next();</span>
        }
<span class="nc bnc" id="L600" title="All 2 branches missed.">        if (returnParams.size() &gt; 1) {</span>
<span class="nc" id="L601">            LOG.warning(&quot;Java generator only handles one return parameter&quot;</span>
<span class="nc" id="L602">                    + &quot; - Found &quot; + returnParams.size() + &quot; for &quot;</span>
<span class="nc" id="L603">                    + Model.getFacade().getName(op));</span>
        }
<span class="nc bnc" id="L605" title="All 4 branches missed.">        if (rp != null &amp;&amp; !constructor) {</span>
<span class="nc" id="L606">            Object returnType = Model.getFacade().getType(rp);</span>
<span class="nc bnc" id="L607" title="All 2 branches missed.">            if (returnType == null) {</span>
<span class="nc" id="L608">                sb.append(&quot;void &quot;);</span>
            } else {
<span class="nc" id="L610">                sb.append(generateClassifierRef(returnType)).append(' ');</span>
            }
        }

        // name and params
<span class="nc" id="L615">        List params = new ArrayList(Model.getFacade().getParameters(op));</span>
<span class="nc" id="L616">        params.remove(rp);</span>

<span class="nc" id="L618">        sb.append(nameStr).append('(');</span>

<span class="nc bnc" id="L620" title="All 2 branches missed.">        if (params != null) {</span>
<span class="nc bnc" id="L621" title="All 2 branches missed.">            for (int i = 0; i &lt; params.size(); i++) {</span>
<span class="nc bnc" id="L622" title="All 2 branches missed.">                if (i &gt; 0) {</span>
<span class="nc" id="L623">                    sb.append(&quot;, &quot;);</span>
                }
<span class="nc" id="L625">                sb.append(generateParameter(params.get(i)));</span>
            }
        }

<span class="nc" id="L629">        sb.append(')');</span>

<span class="nc" id="L631">        Collection c = Model.getFacade().getRaisedSignals(op);</span>
<span class="nc bnc" id="L632" title="All 2 branches missed.">        if (!c.isEmpty()) {</span>
<span class="nc" id="L633">            Iterator it = c.iterator();</span>
<span class="nc" id="L634">            boolean first = true;</span>

<span class="nc bnc" id="L636" title="All 2 branches missed.">            while (it.hasNext()) {</span>
<span class="nc" id="L637">                Object signal = it.next();</span>

<span class="nc bnc" id="L639" title="All 2 branches missed.">                if (!Model.getFacade().isAException(signal)) {</span>
<span class="nc" id="L640">                    continue;</span>
                }

<span class="nc bnc" id="L643" title="All 2 branches missed.">                if (first) {</span>
<span class="nc" id="L644">                    sb.append(&quot; throws &quot;);</span>
                } else {
<span class="nc" id="L646">                    sb.append(&quot;, &quot;);</span>
                }

<span class="nc" id="L649">                sb.append(Model.getFacade().getName(it.next()));</span>
<span class="nc" id="L650">                first = false;</span>
<span class="nc" id="L651">            }</span>
        }

<span class="nc" id="L654">        return sb.toString();</span>
    }

    private String generateAttribute(Object attr, boolean documented) {
<span class="nc bnc" id="L658" title="All 2 branches missed.">        if (isFileGeneration) {</span>
<span class="nc" id="L659">            documented = true; // always &quot;documented&quot; if we generate file.</span>
        }
<span class="nc" id="L661">        StringBuffer sb = new StringBuffer(80);</span>
<span class="nc bnc" id="L662" title="All 2 branches missed.">        if (documented) {</span>
<span class="nc" id="L663">            String s = generateConstraintEnrichedDocComment(attr, documented,</span>
                    INDENT);
<span class="nc bnc" id="L665" title="All 4 branches missed.">            if (s != null &amp;&amp; s.trim().length() &gt; 0) {</span>
<span class="nc" id="L666">                sb.append(s).append(INDENT);</span>
            }
        }
<span class="nc" id="L669">        sb.append(generateCoreAttribute(attr));</span>
<span class="nc" id="L670">        sb.append(&quot;;&quot;).append(LINE_SEPARATOR);</span>

<span class="nc" id="L672">        return sb.toString();</span>
    }

    /**
     * Generates the core attribute for a multiplicity
     * 
     * @param attr The attribute
     * @return a string containing the attribute reference.
     */
    String generateCoreAttribute(Object attr) {
<span class="nc" id="L682">        StringBuffer sb = new StringBuffer(80);</span>
<span class="nc" id="L683">        sb.append(generateVisibility(attr));</span>
<span class="nc" id="L684">        sb.append(generateScope(attr));</span>
<span class="nc" id="L685">        sb.append(generateChangability(attr));</span>
<span class="nc" id="L686">        Object type = Model.getFacade().getType(attr);</span>
<span class="nc" id="L687">        Object multi = Model.getFacade().getMultiplicity(attr);</span>
        // handle multiplicity here since we need the type
        // actually the API of generator is buggy since to generate
        // multiplicity correctly we need the attribute too
<span class="nc bnc" id="L691" title="All 4 branches missed.">        if (type != null &amp;&amp; multi != null) {</span>
<span class="nc bnc" id="L692" title="All 2 branches missed.">            if (Model.getFacade().getUpper(multi) == 1) {</span>
<span class="nc" id="L693">                sb.append(generateClassifierRef(type)).append(' ');</span>
<span class="nc bnc" id="L694" title="All 2 branches missed.">            } else if (Model.getFacade().isADataType(type)) {</span>
<span class="nc" id="L695">                sb.append(generateClassifierRef(type)).append(&quot;[] &quot;);</span>
            } else {
<span class="nc" id="L697">                sb.append(&quot;java.util.List &quot;);</span>
            }
        }

<span class="nc" id="L701">        sb.append(generateName(Model.getFacade().getName(attr)));</span>
<span class="nc" id="L702">        Object init = Model.getFacade().getInitialValue(attr);</span>
<span class="nc bnc" id="L703" title="All 2 branches missed.">        if (init != null) {</span>
<span class="nc" id="L704">            String initStr = generateExpression(init).trim();</span>
<span class="nc bnc" id="L705" title="All 2 branches missed.">            if (initStr.length() &gt; 0) {</span>
<span class="nc" id="L706">                sb.append(&quot; = &quot;).append(initStr);</span>
            }
        }

<span class="nc" id="L710">        return sb.toString();</span>
    }

    /**
     * Generates the literal value for an enumeration
     * 
     * @param literal a literal value for an enumeration.
     * @param documented indicates whether or not the documentation for the
     *            enumeration literal should be generated
     * @param sep a separator character
     * @return a string containing the literal value of an enumeration
     */
    private String generateEnumerationLiteral(Object literal,
            boolean documented, char sep) {
<span class="nc bnc" id="L724" title="All 2 branches missed.">        if (isFileGeneration) {</span>
<span class="nc" id="L725">            documented = true; // always &quot;documented&quot; if we generate file.</span>
        }
<span class="nc" id="L727">        StringBuffer sb = new StringBuffer(80);</span>
<span class="nc bnc" id="L728" title="All 2 branches missed.">        if (documented) {</span>
<span class="nc" id="L729">            String s = generateConstraintEnrichedDocComment(literal,</span>
                    documented, INDENT);
<span class="nc bnc" id="L731" title="All 4 branches missed.">            if (s != null &amp;&amp; s.trim().length() &gt; 0) {</span>
<span class="nc" id="L732">                sb.append(s).append(INDENT);</span>
            }
        }
<span class="nc" id="L735">        sb.append(generateName(Model.getFacade().getName(literal)));</span>
<span class="nc" id="L736">        sb.append(sep).append(LINE_SEPARATOR);</span>

<span class="nc" id="L738">        return sb.toString();</span>
    }

    /**
     * Generates a parameter object.
     * 
     * @param parameter the parameter
     * @return a string containing a parameter
     */
    private String generateParameter(Object parameter) {
<span class="nc" id="L748">        StringBuffer sb = new StringBuffer(20);</span>
        // TODO: qualifiers (e.g., const)
        // TODO: stereotypes...
<span class="nc" id="L751">        sb.append(generateClassifierRef(Model.getFacade().getType(parameter)));</span>
<span class="nc" id="L752">        sb.append(' ');</span>
<span class="nc" id="L753">        sb.append(generateName(Model.getFacade().getName(parameter)));</span>
        // TODO: initial value
<span class="nc" id="L755">        return sb.toString();</span>
    }

    /**
     * Generates the package statement
     * 
     * @param p The package object
     * @return a string containing the package statement
     */
    private String generatePackage(Object p) {
<span class="nc" id="L765">        StringBuffer sb = new StringBuffer(80);</span>
<span class="nc" id="L766">        String packName = generateName(Model.getFacade().getName(p));</span>
<span class="nc" id="L767">        sb.append(&quot;package &quot;).append(packName).append(&quot; {&quot;);</span>
<span class="nc" id="L768">        sb.append(LINE_SEPARATOR);</span>
<span class="nc" id="L769">        Collection ownedElements = Model.getFacade().getOwnedElements(p);</span>
<span class="nc bnc" id="L770" title="All 2 branches missed.">        for (Object modelElement : ownedElements) {</span>
            // This is the only remaining references to generate(), if it
            // can be made more specific, we can remove that method - tfm
            // (do we support anything other than classifiers in a package?)
<span class="nc" id="L774">            sb.append(generate(modelElement));</span>
<span class="nc" id="L775">            sb.append(LINE_SEPARATOR).append(LINE_SEPARATOR);</span>
<span class="nc" id="L776">        }</span>
<span class="nc" id="L777">        sb.append(LINE_SEPARATOR).append(&quot;})&quot;).append(LINE_SEPARATOR);</span>
<span class="nc" id="L778">        return sb.toString();</span>
    }

    /**
     * Generate the start sequence for a classifier. The start sequence is
     * everything from the preceding javadoc comment to the opening curly brace.
     * Start sequences are non-empty for classes and interfaces only.
     * 
     * This method is intended for package internal usage only.
     * 
     * @param cls the classifier for which to generate the start sequence
     * 
     * @return the generated start sequence
     */
    StringBuffer generateClassifierStart(Object cls) {
        String sClassifierKeyword;
<span class="fc bfc" id="L794" title="All 2 branches covered.">        if (Model.getFacade().isAClass(cls)) {</span>
<span class="fc" id="L795">            sClassifierKeyword = &quot;class&quot;;</span>
<span class="pc bpc" id="L796" title="1 of 2 branches missed.">        } else if (Model.getFacade().isAInterface(cls)) {</span>
<span class="fc" id="L797">            sClassifierKeyword = &quot;interface&quot;;</span>
<span class="nc bnc" id="L798" title="All 2 branches missed.">        } else if (Model.getFacade().isAEnumeration(cls)) {</span>
<span class="nc" id="L799">            sClassifierKeyword = &quot;enum&quot;;</span>
        } else {
<span class="nc" id="L801">            return null; // actors, use cases etc.</span>
        }

<span class="fc" id="L804">        StringBuffer sb = new StringBuffer(80);</span>

        // Add the comments for this classifier first.
        // Each pattern here must be similar to corresponding code piece
        // Classfier code piece doesn't start with LINE_SEPARATOR
        // so the next line is commented. See Issue 1505
        // sb.append (LINE_SEPARATOR);
<span class="fc" id="L811">        sb.append(DocumentationManager.getComments(cls));</span>
<span class="fc" id="L812">        sb.append(generateConstraintEnrichedDocComment(cls, true, &quot;&quot;));</span>

        // Now add visibility, but not for non public top level classifiers
<span class="fc bfc" id="L815" title="All 2 branches covered.">        if (Model.getFacade().isPublic(cls)</span>
<span class="fc bfc" id="L816" title="All 2 branches covered.">                || Model.getFacade().isAClassifier(</span>
<span class="fc" id="L817">                        Model.getFacade().getNamespace(cls))) {</span>
<span class="fc" id="L818">            sb.append(generateVisibility(Model.getFacade().getVisibility(cls)));</span>
        }

        // Add other modifiers in JLS order
<span class="pc bpc" id="L822" title="1 of 2 branches missed.">        if (Model.getFacade().isAbstract(cls)</span>
<span class="nc bnc" id="L823" title="All 2 branches missed.">                &amp;&amp; !(Model.getFacade().isAInterface(cls))) {</span>
<span class="nc" id="L824">            sb.append(&quot;abstract &quot;);</span>
        }

<span class="pc bpc" id="L827" title="1 of 2 branches missed.">        if (Model.getFacade().isLeaf(cls)) {</span>
<span class="nc" id="L828">            sb.append(&quot;final &quot;);</span>
        }

        // add additional modifiers
        // TODO: This is for backward compatibility with old models reverse
        // engineered with earlier versions of ArgoUML. As of 0.24, and
        // probably earlier, ArgoUML should be able to capture all necessary
        // information in the model itself. - tfm - 20070217
<span class="fc" id="L836">        Object smod = Model.getFacade().getTaggedValue(cls,</span>
                ImportInterface.SOURCE_MODIFIERS_TAG);
<span class="pc bpc" id="L838" title="3 of 4 branches missed.">        if (smod != null &amp;&amp; Model.getFacade().getValue(smod) != null) {</span>
<span class="nc" id="L839">            sb.append(&quot; &quot;);</span>
<span class="nc" id="L840">            sb.append(Model.getFacade().getValue(smod));</span>
<span class="nc" id="L841">            sb.append(&quot; &quot;);</span>
        }

        // add classifier keyword and classifier name
<span class="fc" id="L845">        sb.append(sClassifierKeyword).append(&quot; &quot;);</span>
<span class="fc" id="L846">        sb.append(generateName(Model.getFacade().getName(cls)));</span>
        // add type parameters
<span class="fc" id="L848">        List templateParameters = Model.getFacade().getTemplateParameters(cls);</span>
<span class="pc bpc" id="L849" title="1 of 2 branches missed.">        for (int i = 0; i &lt; templateParameters.size(); i++) {</span>
<span class="nc bnc" id="L850" title="All 2 branches missed.">            if (i == 0) {</span>
<span class="nc" id="L851">                sb.append(&quot;&lt;&quot;);</span>
            }
<span class="nc" id="L853">            Object param = Model.getFacade().getParameter(</span>
<span class="nc" id="L854">                    templateParameters.get(i));</span>
<span class="nc" id="L855">            sb.append(Model.getFacade().getName(param));</span>
<span class="nc bnc" id="L856" title="All 2 branches missed.">            for (String bound : new String[] {&quot;extends&quot;, &quot;super&quot;}) {</span>
<span class="nc" id="L857">                Object s = Model.getFacade().getTaggedValueValue(param, bound);</span>
<span class="nc bnc" id="L858" title="All 4 branches missed.">                if (s != null &amp;&amp; s.toString().trim().length() &gt; 0) {</span>
<span class="nc" id="L859">                    sb.append(&quot; &quot; + bound + &quot; &quot; + s);</span>
                }
            }
<span class="nc bnc" id="L862" title="All 2 branches missed.">            if (i == templateParameters.size() - 1) {</span>
<span class="nc" id="L863">                sb.append(&quot;&gt;&quot;);</span>
            } else {
<span class="nc" id="L865">                sb.append(&quot;, &quot;);</span>
            }
        }

        // add base class/interface
<span class="fc" id="L870">        String baseClass = generateGeneralization(Model.getFacade()</span>
<span class="fc" id="L871">                .getGeneralizations(cls));</span>
<span class="pc bpc" id="L872" title="1 of 2 branches missed.">        if (!baseClass.equals(&quot;&quot;)) {</span>
<span class="nc" id="L873">            sb.append(&quot; &quot;).append(&quot;extends &quot;).append(baseClass);</span>
        }

        // add implemented interfaces, if needed
        // UML: realizations!
<span class="fc bfc" id="L878" title="All 2 branches covered.">        if (Model.getFacade().isAClass(cls)) {</span>
<span class="fc" id="L879">            String interfaces = generateSpecification(cls);</span>
<span class="fc" id="L880">            LOG.fine(&quot;Specification: &quot; + interfaces);</span>
<span class="pc bpc" id="L881" title="1 of 2 branches missed.">            if (!interfaces.equals(&quot;&quot;)) {</span>
<span class="nc" id="L882">                sb.append(&quot; &quot;).append(&quot;implements &quot;).append(interfaces);</span>
            }
        }

        // add opening brace
<span class="pc bpc" id="L887" title="1 of 2 branches missed.">        sb.append(lfBeforeCurly ? (LINE_SEPARATOR + &quot;{&quot;) : &quot; {&quot;);</span>

        // list tagged values for documentation
<span class="fc" id="L890">        String tv = generateTaggedValues(cls);</span>
<span class="pc bpc" id="L891" title="2 of 4 branches missed.">        if (tv != null &amp;&amp; tv.length() &gt; 0) {</span>
<span class="nc" id="L892">            sb.append(LINE_SEPARATOR).append(INDENT).append(tv);</span>
        }

<span class="fc" id="L895">        return sb;</span>
    }

    /**
     * Generates the code for a classifer end
     * 
     * @param cls The classifier
     * @return a StringBuffer containing the classifier end
     */
    private StringBuffer generateClassifierEnd(Object cls) {
<span class="nc" id="L905">        StringBuffer sb = new StringBuffer();</span>
<span class="nc bnc" id="L906" title="All 2 branches missed.">        if (Model.getFacade().isAClass(cls)</span>
<span class="nc bnc" id="L907" title="All 2 branches missed.">                || Model.getFacade().isAInterface(cls)</span>
<span class="nc bnc" id="L908" title="All 2 branches missed.">                || Model.getFacade().isAEnumeration(cls)) {</span>
<span class="nc bnc" id="L909" title="All 2 branches missed.">            if (verboseDocs) {</span>
<span class="nc" id="L910">                String classifierkeyword = null;</span>
<span class="nc bnc" id="L911" title="All 2 branches missed.">                if (Model.getFacade().isAClass(cls)) {</span>
<span class="nc" id="L912">                    classifierkeyword = &quot;class&quot;;</span>
                } else {
<span class="nc" id="L914">                    classifierkeyword = &quot;interface&quot;;</span>
                }
<span class="nc" id="L916">                sb.append(LINE_SEPARATOR);</span>
<span class="nc" id="L917">                sb.append(&quot;//end of &quot;).append(classifierkeyword);</span>
<span class="nc" id="L918">                sb.append(&quot; &quot;).append(Model.getFacade().getName(cls));</span>
<span class="nc" id="L919">                sb.append(LINE_SEPARATOR);</span>
            }
<span class="nc" id="L921">            sb.append(LINE_SEPARATOR);</span>
<span class="nc" id="L922">            sb.append(&quot;}&quot;);</span>
        }
<span class="nc" id="L924">        return sb;</span>
    }

    /**
     * Append the classifier end sequence to the prefix text specified. The
     * classifier end sequence is the closing curly brace together with any
     * comments marking the end of the classifier.
     * 
     * This method is intended for package internal usage.
     * 
     * @param sbPrefix the prefix text to be amended. It is OK to call append on
     *            this parameter.
     * @param cls the classifier for which to generate the classifier end
     *            sequence. Only classes and interfaces have a classifier end
     *            sequence.
     * @return the complete classifier code, i.e., sbPrefix plus the classifier
     *         end sequence
     */
    StringBuffer appendClassifierEnd(StringBuffer sbPrefix, Object cls) {
<span class="nc" id="L943">        sbPrefix.append(generateClassifierEnd(cls));</span>

<span class="nc" id="L945">        return sbPrefix;</span>
    }

    /**
     * Generates code for a classifier. In case of Java code is generated for
     * classes and interfaces only at the moment.
     * 
     * @param cls a classifier object
     */
    private String generateClassifier(Object cls) {
<span class="nc" id="L955">        StringBuffer returnValue = new StringBuffer();</span>
<span class="nc" id="L956">        StringBuffer start = generateClassifierStart(cls);</span>
<span class="nc bnc" id="L957" title="All 4 branches missed.">        if ((start != null) &amp;&amp; (start.length() &gt; 0)) {</span>
<span class="nc" id="L958">            StringBuffer body = generateClassifierBody(cls);</span>
<span class="nc" id="L959">            StringBuffer end = generateClassifierEnd(cls);</span>
<span class="nc" id="L960">            returnValue.append(start.toString());</span>
<span class="nc bnc" id="L961" title="All 4 branches missed.">            if ((body != null) &amp;&amp; (body.length() &gt; 0)) {</span>
<span class="nc" id="L962">                returnValue.append(LINE_SEPARATOR);</span>
<span class="nc" id="L963">                returnValue.append(body);</span>
<span class="nc bnc" id="L964" title="All 2 branches missed.">                if (lfBeforeCurly) {</span>
<span class="nc" id="L965">                    returnValue.append(LINE_SEPARATOR);</span>
                }
            }
<span class="nc bnc" id="L968" title="All 2 branches missed.">            returnValue.append((end != null) ? end.toString() : &quot;&quot;);</span>
        }
<span class="nc" id="L970">        return returnValue.toString();</span>
    }

    /**
     * Generates the body of a class or interface.
     * 
     * @param cls The classifier object (either a class, interface or
     *            enumeration.
     */
    private StringBuffer generateClassifierBody(Object cls) {
<span class="nc" id="L980">        StringBuffer sb = new StringBuffer();</span>
<span class="nc bnc" id="L981" title="All 2 branches missed.">        if (Model.getFacade().isAClass(cls)</span>
<span class="nc bnc" id="L982" title="All 2 branches missed.">                || Model.getFacade().isAInterface(cls)</span>
<span class="nc bnc" id="L983" title="All 2 branches missed.">                || Model.getFacade().isAEnumeration(cls)) {</span>
<span class="nc" id="L984">            String tv = null; // helper for tagged values</span>

            // add attributes
<span class="nc" id="L987">            Collection sFeatures = Model.getFacade().getStructuralFeatures(cls);</span>

<span class="nc bnc" id="L989" title="All 2 branches missed.">            if (!sFeatures.isEmpty()) {</span>
<span class="nc" id="L990">                sb.append(LINE_SEPARATOR);</span>
<span class="nc bnc" id="L991" title="All 4 branches missed.">                if (verboseDocs &amp;&amp; Model.getFacade().isAClass(cls)) {</span>
<span class="nc" id="L992">                    sb.append(INDENT).append(&quot;// Attributes&quot;);</span>
<span class="nc" id="L993">                    sb.append(LINE_SEPARATOR);</span>
                }

<span class="nc" id="L996">                boolean first = true;</span>
<span class="nc bnc" id="L997" title="All 2 branches missed.">                for (Object structuralFeature : sFeatures) {</span>
<span class="nc bnc" id="L998" title="All 2 branches missed.">                    if (!first) {</span>
<span class="nc" id="L999">                        sb.append(LINE_SEPARATOR);</span>
                    }
<span class="nc" id="L1001">                    sb.append(INDENT);</span>
                    // The only type of StructuralFeature is an Attribute
<span class="nc" id="L1003">                    sb.append(generateAttribute(structuralFeature, false));</span>

<span class="nc" id="L1005">                    tv = generateTaggedValues(structuralFeature);</span>
<span class="nc bnc" id="L1006" title="All 4 branches missed.">                    if (tv != null &amp;&amp; tv.length() &gt; 0) {</span>
<span class="nc" id="L1007">                        sb.append(INDENT).append(tv);</span>
                    }
<span class="nc" id="L1009">                    first = false;</span>
<span class="nc" id="L1010">                }</span>
            }

<span class="nc bnc" id="L1013" title="All 2 branches missed.">            if (Model.getFacade().isAEnumeration(cls)) {</span>
<span class="nc" id="L1014">                addLiterals(cls, sb);</span>
            }

<span class="nc" id="L1017">            Collection ends = Model.getFacade().getAssociationEnds(cls);</span>
<span class="nc bnc" id="L1018" title="All 2 branches missed.">            if (!ends.isEmpty()) {</span>
<span class="nc" id="L1019">                addAttributesImplementingAssociations(cls, sb, ends);</span>
            }

            // Inner classes
<span class="nc" id="L1023">            Collection elements = Model.getFacade().getOwnedElements(cls);</span>
<span class="nc bnc" id="L1024" title="All 2 branches missed.">            for (Iterator i = elements.iterator(); i.hasNext();) {</span>
<span class="nc" id="L1025">                Object element = i.next();</span>
<span class="nc bnc" id="L1026" title="All 2 branches missed.">                if (Model.getFacade().isAClass(element)</span>
<span class="nc bnc" id="L1027" title="All 2 branches missed.">                        || Model.getFacade().isAInterface(element)) {</span>

<span class="nc" id="L1029">                    sb.append(generateClassifier(element));</span>
                }
<span class="nc" id="L1031">            }</span>

            // add operations
            // TODO: constructors
<span class="nc" id="L1035">            Collection bFeatures = Model.getFacade().getOperations(cls);</span>

<span class="nc bnc" id="L1037" title="All 2 branches missed.">            if (!bFeatures.isEmpty()) {</span>
<span class="nc" id="L1038">                addOperations(cls, sb, bFeatures);</span>
            }
        }
<span class="nc" id="L1041">        return sb;</span>
    }

    /**
     * Generates the operations
     * 
     * @param cls The classifier object
     * @param sb The StringBuffer to which the operations will be added
     * @param bFeatures a collection of behavioral features
     */
    private void addOperations(Object cls,
                               StringBuffer sb,
                               Collection bFeatures) {
        String tv;
<span class="nc" id="L1055">        sb.append(LINE_SEPARATOR);</span>
<span class="nc bnc" id="L1056" title="All 2 branches missed.">        if (verboseDocs) {</span>
<span class="nc" id="L1057">            sb.append(INDENT).append(&quot;// Operations&quot;);</span>
<span class="nc" id="L1058">            sb.append(LINE_SEPARATOR);</span>
        }

<span class="nc" id="L1061">        boolean first = true;</span>
<span class="nc bnc" id="L1062" title="All 2 branches missed.">        for (Object behavioralFeature : bFeatures) {</span>

<span class="nc bnc" id="L1064" title="All 2 branches missed.">            if (!first) {</span>
<span class="nc" id="L1065">                sb.append(LINE_SEPARATOR);</span>
            }
<span class="nc" id="L1067">            sb.append(INDENT);</span>
<span class="nc" id="L1068">            sb.append(generateOperation(behavioralFeature, false));</span>

<span class="nc" id="L1070">            tv = generateTaggedValues(behavioralFeature);</span>

<span class="nc bnc" id="L1072" title="All 2 branches missed.">            if ((Model.getFacade().isAClass(cls))</span>
<span class="nc bnc" id="L1073" title="All 2 branches missed.">                    &amp;&amp; (Model.getFacade().isAOperation(behavioralFeature))</span>
<span class="nc bnc" id="L1074" title="All 2 branches missed.">                    &amp;&amp; (!Model.getFacade().isAbstract(behavioralFeature))) {</span>
<span class="nc bnc" id="L1075" title="All 2 branches missed.">                if (lfBeforeCurly) {</span>
<span class="nc" id="L1076">                    sb.append(LINE_SEPARATOR).append(INDENT);</span>
                } else {
<span class="nc" id="L1078">                    sb.append(' ');</span>
                }
<span class="nc" id="L1080">                sb.append('{');</span>

<span class="nc bnc" id="L1082" title="All 2 branches missed.">                if (tv.length() &gt; 0) {</span>
<span class="nc" id="L1083">                    sb.append(LINE_SEPARATOR).append(INDENT).append(tv);</span>
                }

                // there is no ReturnType in behavioral feature (UML)
<span class="nc" id="L1087">                sb.append(LINE_SEPARATOR);</span>
<span class="nc" id="L1088">                sb.append(generateMethodBody(behavioralFeature));</span>
<span class="nc" id="L1089">                sb.append(INDENT);</span>
<span class="nc" id="L1090">                sb.append(&quot;}&quot;).append(LINE_SEPARATOR);</span>
            } else {
<span class="nc" id="L1092">                sb.append(&quot;;&quot;).append(LINE_SEPARATOR);</span>
<span class="nc bnc" id="L1093" title="All 2 branches missed.">                if (tv.length() &gt; 0) {</span>
<span class="nc" id="L1094">                    sb.append(INDENT).append(tv).append(LINE_SEPARATOR);</span>
                }
            }

<span class="nc" id="L1098">            first = false;</span>
<span class="nc" id="L1099">        }</span>
<span class="nc" id="L1100">    }</span>

    /**
     * This method adds attribute associations to the string buffer.
     * 
     * @param cls The class object
     * @param sb The StringBuffer containing the text of the generated class.
     * @param ends The association ends
     */
    private void addAttributesImplementingAssociations(Object cls,
            StringBuffer sb, Collection ends) {
        String tv;
<span class="nc" id="L1112">        sb.append(LINE_SEPARATOR);</span>
<span class="nc bnc" id="L1113" title="All 4 branches missed.">        if (verboseDocs &amp;&amp; Model.getFacade().isAClass(cls)) {</span>
<span class="nc" id="L1114">            sb.append(INDENT).append(&quot;// Associations&quot;);</span>
<span class="nc" id="L1115">            sb.append(LINE_SEPARATOR);</span>
        }

<span class="nc bnc" id="L1118" title="All 2 branches missed.">        for (Object associationEnd : ends) {</span>
<span class="nc" id="L1119">            Object association = Model.getFacade().getAssociation(</span>
                    associationEnd);

<span class="nc" id="L1122">            sb.append(generateAssociationFrom(association, associationEnd));</span>

<span class="nc" id="L1124">            tv = generateTaggedValues(association);</span>
<span class="nc bnc" id="L1125" title="All 4 branches missed.">            if (tv != null &amp;&amp; tv.length() &gt; 0) {</span>
<span class="nc" id="L1126">                sb.append(INDENT).append(tv);</span>
            }
<span class="nc" id="L1128">        }</span>
<span class="nc" id="L1129">    }</span>

    /**
     * This method adds enumeration literals to the StringBuffer
     * 
     * @param cls The class object
     * @param sb The StringBuffer containing the generated class
     */
    private void addLiterals(Object cls, StringBuffer sb) {
        String tv;
<span class="nc" id="L1139">        Collection literals = Model.getFacade().getEnumerationLiterals(cls);</span>

<span class="nc bnc" id="L1141" title="All 2 branches missed.">        if (!literals.isEmpty()) {</span>
<span class="nc" id="L1142">            sb.append(LINE_SEPARATOR);</span>
<span class="nc bnc" id="L1143" title="All 2 branches missed.">            if (verboseDocs) {</span>
<span class="nc" id="L1144">                sb.append(INDENT).append(&quot;// Literals&quot;);</span>
<span class="nc" id="L1145">                sb.append(LINE_SEPARATOR);</span>
            }

<span class="nc" id="L1148">            boolean first = true;</span>
<span class="nc" id="L1149">            int size = literals.size();</span>
<span class="nc" id="L1150">            int cnt = 0;</span>
<span class="nc bnc" id="L1151" title="All 2 branches missed.">            for (Object literal : literals) {</span>
<span class="nc" id="L1152">                cnt++;</span>
<span class="nc bnc" id="L1153" title="All 2 branches missed.">                if (!first) {</span>
<span class="nc" id="L1154">                    sb.append(LINE_SEPARATOR);</span>
                }
<span class="nc" id="L1156">                sb.append(INDENT);</span>
<span class="nc bnc" id="L1157" title="All 2 branches missed.">                char sep = cnt != size ? ',' : ';';</span>
<span class="nc" id="L1158">                sb.append(generateEnumerationLiteral(literal, false, sep));</span>

<span class="nc" id="L1160">                tv = generateTaggedValues(literal);</span>
<span class="nc bnc" id="L1161" title="All 4 branches missed.">                if (tv != null &amp;&amp; tv.length() &gt; 0) {</span>
<span class="nc" id="L1162">                    sb.append(INDENT).append(tv);</span>
                }
<span class="nc" id="L1164">                first = false;</span>
<span class="nc" id="L1165">            }</span>
        }
<span class="nc" id="L1167">    }</span>

    /**
     * Generate the body of a method associated with the given operation. This
     * assumes there's at most one method associated!
     * 
     * If no method is associated with the operation, a default method body will
     * be generated.
     * 
     * @param op The operation object
     */
    private String generateMethodBody(Object op) {
        // cat.info(&quot;generateMethodBody&quot;);
<span class="nc bnc" id="L1180" title="All 2 branches missed.">        if (op != null) {</span>
<span class="nc bnc" id="L1181" title="All 2 branches missed.">            for (Object m : Model.getFacade().getMethods(op)) {</span>
<span class="nc bnc" id="L1182" title="All 2 branches missed.">                if (m != null) {</span>
<span class="nc bnc" id="L1183" title="All 2 branches missed.">                    if (Model.getFacade().getBody(m) != null) {</span>
<span class="nc" id="L1184">                        String body = (String) Model.getFacade().getBody(</span>
<span class="nc" id="L1185">                                Model.getFacade().getBody(m));</span>
                        // Note that this will not preserve empty lines
                        // in the body
<span class="nc" id="L1188">                        StringTokenizer tokenizer = new StringTokenizer(body,</span>
                                &quot;\r\n&quot;);
<span class="nc" id="L1190">                        StringBuffer bsb = new StringBuffer();</span>
<span class="nc bnc" id="L1191" title="All 2 branches missed.">                        while (tokenizer.hasMoreTokens()) {</span>
<span class="nc" id="L1192">                            String token = tokenizer.nextToken();</span>
<span class="nc bnc" id="L1193" title="All 2 branches missed.">                            if (token.length() &gt; 0) {</span>
<span class="nc" id="L1194">                                bsb.append(token);</span>
<span class="nc" id="L1195">                                bsb.append(LINE_SEPARATOR);</span>
                            }
<span class="nc" id="L1197">                        }</span>
<span class="nc bnc" id="L1198" title="All 2 branches missed.">                        if (bsb.length() &lt;= 0) {</span>
                            // generateClassifierBody relies on the string
                            // ending with a new-line
<span class="nc" id="L1201">                            bsb.append(LINE_SEPARATOR);</span>
                        }
<span class="nc" id="L1203">                        return bsb.toString();</span>
                    }
<span class="nc" id="L1205">                    return &quot;&quot;;</span>
                }
<span class="nc" id="L1207">            }</span>

            // pick out return type
<span class="nc" id="L1210">            Collection returnParams = Model.getCoreHelper()</span>
<span class="nc" id="L1211">                    .getReturnParameters(op);</span>
            Object rp;
<span class="nc bnc" id="L1213" title="All 2 branches missed.">            if (returnParams.size() == 0) {</span>
<span class="nc" id="L1214">                rp = null;</span>
            } else {
<span class="nc" id="L1216">                rp = returnParams.iterator().next();</span>
            }
<span class="nc bnc" id="L1218" title="All 2 branches missed.">            if (returnParams.size() &gt; 1) {</span>
<span class="nc" id="L1219">                LOG.warning(&quot;Java generator only handles one return parameter&quot;</span>
<span class="nc" id="L1220">                            + &quot; - Found &quot; + returnParams.size() + &quot; for &quot;</span>
<span class="nc" id="L1221">                            + Model.getFacade().getName(op));</span>
            }
<span class="nc bnc" id="L1223" title="All 2 branches missed.">            if (rp != null) {</span>
<span class="nc" id="L1224">                Object returnType = Model.getFacade().getType(rp);</span>
<span class="nc" id="L1225">                return generateDefaultReturnStatement(returnType);</span>
            }
        }

<span class="nc" id="L1229">        return generateDefaultReturnStatement(null);</span>
    }

    /**
     * This method generates default return statements for methods
     * 
     * @param cls The class object
     * @return
     */
    private String generateDefaultReturnStatement(Object cls) {
<span class="nc bnc" id="L1239" title="All 2 branches missed.">        if (cls == null) {</span>
<span class="nc" id="L1240">            return &quot;&quot;;</span>
        }

<span class="nc" id="L1243">        String clsName = Model.getFacade().getName(cls);</span>
<span class="nc bnc" id="L1244" title="All 2 branches missed.">        if (clsName.equals(&quot;void&quot;)) {</span>
<span class="nc" id="L1245">            return &quot;&quot;;</span>
        }
<span class="nc bnc" id="L1247" title="All 2 branches missed.">        if (clsName.equals(&quot;char&quot;)) {</span>
<span class="nc" id="L1248">            return INDENT + &quot;return 'x';&quot; + LINE_SEPARATOR;</span>
        }
<span class="nc bnc" id="L1250" title="All 2 branches missed.">        if (clsName.equals(&quot;int&quot;)) {</span>
<span class="nc" id="L1251">            return INDENT + &quot;return 0;&quot; + LINE_SEPARATOR;</span>
        }
<span class="nc bnc" id="L1253" title="All 2 branches missed.">        if (clsName.equals(&quot;boolean&quot;)) {</span>
<span class="nc" id="L1254">            return INDENT + &quot;return false;&quot; + LINE_SEPARATOR;</span>
        }
<span class="nc bnc" id="L1256" title="All 2 branches missed.">        if (clsName.equals(&quot;byte&quot;)) {</span>
<span class="nc" id="L1257">            return INDENT + &quot;return 0;&quot; + LINE_SEPARATOR;</span>
        }
<span class="nc bnc" id="L1259" title="All 2 branches missed.">        if (clsName.equals(&quot;long&quot;)) {</span>
<span class="nc" id="L1260">            return INDENT + &quot;return 0;&quot; + LINE_SEPARATOR;</span>
        }
<span class="nc bnc" id="L1262" title="All 2 branches missed.">        if (clsName.equals(&quot;float&quot;)) {</span>
<span class="nc" id="L1263">            return INDENT + &quot;return 0.0;&quot; + LINE_SEPARATOR;</span>
        }
<span class="nc bnc" id="L1265" title="All 2 branches missed.">        if (clsName.equals(&quot;double&quot;)) {</span>
<span class="nc" id="L1266">            return INDENT + &quot;return 0.0;&quot; + LINE_SEPARATOR;</span>
        }
<span class="nc" id="L1268">        return INDENT + &quot;return null;&quot; + LINE_SEPARATOR;</span>
    }

    /**
     * This method generates the tagged values
     * 
     * @param e
     * @return a String containing the tagged values.
     */
    private String generateTaggedValues(Object e) {
<span class="pc bpc" id="L1278" title="1 of 2 branches missed.">        if (isInUpdateMode) {</span>
<span class="nc" id="L1279">            return &quot;&quot;; // no tagged values are generated in update mode.</span>
        }
<span class="fc" id="L1281">        Iterator iter = Model.getFacade().getTaggedValues(e);</span>
<span class="pc bpc" id="L1282" title="1 of 2 branches missed.">        if (iter == null) {</span>
<span class="nc" id="L1283">            return &quot;&quot;;</span>
        }
<span class="fc" id="L1285">        boolean first = true;</span>
<span class="fc" id="L1286">        StringBuffer buf = new StringBuffer();</span>
<span class="fc" id="L1287">        String s = null;</span>
<span class="pc bpc" id="L1288" title="1 of 2 branches missed.">        while (iter.hasNext()) {</span>
            /*
             * 2002-11-07 Jaap Branderhorst Was
             * 
             * s = generateTaggedValue((MTaggedValue) iter.next());
             * 
             * which caused problems because the test tags (i.e. tags with name
             * &lt;NotationName.getName()&gt;+TEST_SUFFIX) were still generated.
             * 
             * New code:
             */
<span class="nc" id="L1299">            s = generateTaggedValue(iter.next());</span>
            // end new code
<span class="nc bnc" id="L1301" title="All 4 branches missed.">            if (s != null &amp;&amp; s.length() &gt; 0) {</span>
<span class="nc bnc" id="L1302" title="All 2 branches missed.">                if (first) {</span>
<span class="nc" id="L1303">                    buf.append(&quot;/* {&quot;);</span>

<span class="nc" id="L1305">                    first = false;</span>
                } else {
<span class="nc" id="L1307">                    buf.append(&quot;, &quot;);</span>
                }
<span class="nc" id="L1309">                buf.append(s);</span>
            }
        }
        /*
         * Corrected 2001-09-26 STEFFEN ZSCHALER
         * 
         * Was: if (!first) buf.append(&quot;}\n&quot;);
         * 
         * which caused problems with new-lines in tagged values.
         */
<span class="pc bpc" id="L1319" title="1 of 2 branches missed.">        if (!first) {</span>
<span class="nc" id="L1320">            buf.append(&quot;}*/&quot;).append(LINE_SEPARATOR);</span>
        }

<span class="fc" id="L1323">        return buf.toString();</span>
    }

    /**
     * Generates a tagged value
     * 
     * @param tv a tagged value object
     * @return a String containing the tagged values (usually comments).
     */
    private String generateTaggedValue(Object tv) {
<span class="nc bnc" id="L1333" title="All 2 branches missed.">        if (tv == null) {</span>
<span class="nc" id="L1334">            return &quot;&quot;;</span>
        }
<span class="nc" id="L1336">        String s = generateUninterpreted(Model.getFacade().getValueOfTag(tv));</span>
<span class="nc bnc" id="L1337" title="All 6 branches missed.">        if (s == null || s.length() == 0 || s.equals(&quot;/** */&quot;)) {</span>
<span class="nc" id="L1338">            return &quot;&quot;;</span>
        }
<span class="nc" id="L1340">        String t = Model.getFacade().getTagOfTag(tv);</span>
<span class="nc bnc" id="L1341" title="All 2 branches missed.">        if (Argo.DOCUMENTATION_TAG.equals(t)) {</span>
<span class="nc" id="L1342">            return &quot;&quot;;</span>
        }
<span class="nc" id="L1344">        return generateName(t) + &quot;=&quot; + s;</span>
    }

    /**
     * Enhance/Create the doc comment for the given model element, including
     * tags for any OCL constraints connected to the model element. The tags
     * generated are suitable for use with the ocl injector which is part of the
     * Dresden OCL Toolkit and are in detail:
     * 
     * &amp;nbsp;@invariant for each invariant specified &amp;nbsp;@precondition for
     * each precondition specified &amp;nbsp;@postcondition for each postcondition
     * specified &amp;nbsp;@key-type specifying the class of the keys of a mapped
     * association &amp;nbsp; Currently mapped associations are not supported yet...
     * &amp;nbsp;@element-type specifying the class referenced in an association
     * 
     * @since 2001-09-26 ArgoUML 0.9.3
     * @author Steffen Zschaler
     * 
     * @param me the model element for which the documentation comment is needed
     * @param ae the association end which is represented by the model element
     * @return the documentation comment for the specified model element, either
     *         enhanced or completely generated
     */
    private String generateConstraintEnrichedDocComment(Object me, Object ae) {
<span class="nc" id="L1368">        String s = generateConstraintEnrichedDocComment(me, true, INDENT);</span>

<span class="nc bnc" id="L1370" title="All 2 branches missed.">        if (isCollection(ae)) {</span>
            // Multiplicity greater 1, that means we will generate some sort of
            // collection, so we need to specify the element type tag
<span class="nc" id="L1373">            StringBuffer sDocComment = new StringBuffer(80);</span>

            // Prepare doc comment
<span class="nc bnc" id="L1376" title="All 4 branches missed.">            if (!(s == null || &quot;&quot;.equals(s))) {</span>
                // Just remove closing &quot;*/&quot;
<span class="nc" id="L1378">                sDocComment.append(s.substring(0, s.indexOf(&quot;*/&quot;) + 1));</span>
            } else {
<span class="nc" id="L1380">                sDocComment.append(INDENT).append(&quot;/**&quot;).append(LINE_SEPARATOR);</span>
<span class="nc" id="L1381">                sDocComment.append(INDENT).append(&quot;  * &quot;)</span>
<span class="nc" id="L1382">                        .append(LINE_SEPARATOR);</span>
<span class="nc" id="L1383">                sDocComment.append(INDENT).append(&quot;  *&quot;);</span>
            }

            // Build doc comment
            // Object type = Model.getFacade().getType(ae);
            // if (type != null) {
            // sDocComment.append(&quot; @element-type &quot;);
            // sDocComment.append(Model.getFacade().getName(type));
            // }

            // REMOVED: 2002-03-11 STEFFEN ZSCHALER: element type
            // unknown is not recognized by the OCL injector...
            // else {
            // sDocComment += &quot; @element-type unknown&quot;;
            // }
<span class="nc" id="L1398">            sDocComment.append(LINE_SEPARATOR).append(INDENT).append(&quot; */&quot;);</span>
<span class="nc" id="L1399">            sDocComment.append(LINE_SEPARATOR);</span>
<span class="nc" id="L1400">            return sDocComment.toString();</span>
        }
<span class="nc bnc" id="L1402" title="All 2 branches missed.">        return (s != null) ? s : &quot;&quot;;</span>
    }

    /**
     * @param element ModelElement which has the Multiplicity
     * @return true if multiplicity is non-null and upper bound is greater than
     *         1
     */
    private boolean isCollection(Object element) {
<span class="nc" id="L1411">        Object multiplicity = Model.getFacade().getMultiplicity(element);</span>
<span class="nc bnc" id="L1412" title="All 2 branches missed.">        if (multiplicity != null) {</span>
<span class="nc" id="L1413">            int upper = Model.getFacade().getUpper(multiplicity);</span>
            // -1 is UML's special 'unlimited integer'
<span class="nc bnc" id="L1415" title="All 4 branches missed.">            if (upper &gt; 1 || upper == -1) {</span>
<span class="nc" id="L1416">                return true;</span>
            }
        }
<span class="nc" id="L1419">        return false;</span>
    }

    /**
     * Enhance/Create the doc comment for the given model element, including
     * tags for any OCL constraints connected to the model element. The tags
     * generated are suitable for use with the ocl injector which is part of the
     * Dresden OCL Toolkit and are in detail:
     * 
     * &amp;nbsp;@invariant for each invariant specified &amp;nbsp;@precondition for
     * each precondition specified &amp;nbsp;@postcondition for each postcondition
     * specified
     * 
     * @since 2001-09-26 ArgoUML 0.9.3
     * @author Steffen Zschaler
     * 
     * @param me the model element for which the documentation comment is needed
     * @param documented if existing tagged values should be generated in
     *            addition to javadoc
     * @param indent indent String (usually blanks) for indentation of generated
     *            comments
     * @return the documentation comment for the specified model element, either
     *         enhanced or completely generated
     */
    public static String generateConstraintEnrichedDocComment(Object me,
            boolean documented, String indent) {
<span class="pc bpc" id="L1445" title="1 of 2 branches missed.">        if (isFileGeneration) {</span>
<span class="nc" id="L1446">            documented = true; // always &quot;documented&quot; if we generate file</span>
        }
        // Retrieve any existing doc comment
<span class="pc bpc" id="L1449" title="1 of 2 branches missed.">        String s = (VERBOSE_DOCS || DocumentationManager.hasDocs(me))</span>
<span class="nc" id="L1450">            ? DocumentationManager.getDocs(me, indent)</span>
<span class="fc" id="L1451">            : null;</span>
<span class="fc" id="L1452">        StringBuffer sDocComment = new StringBuffer(80);</span>

<span class="pc bpc" id="L1454" title="3 of 4 branches missed.">        if (s != null &amp;&amp; s.trim().length() &gt; 0) {</span>
<span class="nc" id="L1455">            sDocComment.append(s).append(LINE_SEPARATOR);</span>
        }
<span class="fc" id="L1457">        LOG.fine(&quot;documented=&quot; + documented);</span>
<span class="pc bpc" id="L1458" title="1 of 2 branches missed.">        if (!documented) {</span>
<span class="nc" id="L1459">            return sDocComment.toString();</span>
        }

        // Extract constraints
<span class="fc" id="L1463">        Collection cConstraints = Model.getFacade().getConstraints(me);</span>

<span class="pc bpc" id="L1465" title="1 of 2 branches missed.">        if (cConstraints.size() == 0) {</span>
<span class="fc" id="L1466">            return sDocComment.toString();</span>
        }

        // Prepare doc comment
<span class="nc bnc" id="L1470" title="All 2 branches missed.">        if (s != null) {</span>
            // Just remove closing */
<span class="nc" id="L1472">            s = sDocComment.toString();</span>
<span class="nc" id="L1473">            sDocComment = new StringBuffer(s.substring(0, s.indexOf(&quot;*/&quot;) + 1));</span>
        } else {
<span class="nc" id="L1475">            sDocComment.append(INDENT).append(&quot;/**&quot;).append(LINE_SEPARATOR);</span>
<span class="nc" id="L1476">            sDocComment.append(INDENT).append(&quot; * &quot;).append(LINE_SEPARATOR);</span>
<span class="nc" id="L1477">            sDocComment.append(INDENT).append(&quot; *&quot;);</span>
        }

        // Add each constraint

        class TagExtractor extends DepthFirstAdapter {
<span class="nc" id="L1483">            private LinkedList&lt;String&gt; llsTags = new LinkedList&lt;String&gt;();</span>

            private String constraintName;

            private int constraintID;

            /**
             * Constructor.
             * 
             * @param sConstraintName The constraint name.
             */
            public TagExtractor(String sConstraintName) {
<span class="nc" id="L1495">                super();</span>

<span class="nc" id="L1497">                constraintName = sConstraintName;</span>
<span class="nc" id="L1498">            }</span>

            public Iterator getTags() {
<span class="nc" id="L1501">                return llsTags.iterator();</span>
            }

            /*
             * @see tudresden.ocl.parser.analysis.Analysis#caseAConstraintBody(tudresden.ocl.parser.node.AConstraintBody)
             */
            @Override
            public void caseAConstraintBody(AConstraintBody node) {
                // We don't care for anything below this node, so we
                // do not use apply anymore.
<span class="nc bnc" id="L1511" title="All 2 branches missed.">                String sKind = (node.getStereotype() != null) ? (node</span>
<span class="nc" id="L1512">                        .getStereotype().toString()) : (null);</span>
<span class="nc bnc" id="L1513" title="All 2 branches missed.">                String sExpression = (node.getExpression() != null) ? (node</span>
<span class="nc" id="L1514">                        .getExpression().toString()) : (null);</span>
<span class="nc bnc" id="L1515" title="All 2 branches missed.">                String sName = (node.getName() != null) ? (node.getName()</span>
<span class="nc" id="L1516">                        .getText()) : (constraintName + &quot;_&quot; + (constraintID++));</span>

<span class="nc bnc" id="L1518" title="All 4 branches missed.">                if ((sKind == null) || (sExpression == null)) {</span>
<span class="nc" id="L1519">                    return;</span>
                }

                String sTag;
<span class="nc bnc" id="L1523" title="All 2 branches missed.">                if (sKind.equals(&quot;inv &quot;)) {</span>
<span class="nc" id="L1524">                    sTag = &quot;@invariant &quot;;</span>
<span class="nc bnc" id="L1525" title="All 2 branches missed.">                } else if (sKind.equals(&quot;post &quot;)) {</span>
<span class="nc" id="L1526">                    sTag = &quot;@postcondition &quot;;</span>
<span class="nc bnc" id="L1527" title="All 2 branches missed.">                } else if (sKind.equals(&quot;pre &quot;)) {</span>
<span class="nc" id="L1528">                    sTag = &quot;@precondition &quot;;</span>
                } else {
<span class="nc" id="L1530">                    return;</span>
                }

<span class="nc" id="L1533">                sTag += sName + &quot;: &quot; + sExpression;</span>
<span class="nc" id="L1534">                llsTags.addLast(sTag);</span>
<span class="nc" id="L1535">            }</span>
        }

<span class="nc" id="L1538">        tudresden.ocl.check.types.ModelFacade mf = new ArgoFacade(me);</span>
<span class="nc bnc" id="L1539" title="All 2 branches missed.">        for (Object constraint : cConstraints) {</span>
            try {
<span class="nc" id="L1541">                String body = (String) Model.getFacade().getBody(</span>
<span class="nc" id="L1542">                        Model.getFacade().getBody(constraint));</span>
<span class="nc" id="L1543">                OclTree otParsed = OclTree.createTree(body, mf);</span>

<span class="nc" id="L1545">                TagExtractor te = new TagExtractor(Model.getFacade().getName(</span>
                        constraint));
<span class="nc" id="L1547">                otParsed.apply(te);</span>

<span class="nc bnc" id="L1549" title="All 2 branches missed.">                for (Iterator j = te.getTags(); j.hasNext();) {</span>
<span class="nc" id="L1550">                    sDocComment.append(' ').append(j.next());</span>
<span class="nc" id="L1551">                    sDocComment.append(LINE_SEPARATOR);</span>
<span class="nc" id="L1552">                    sDocComment.append(INDENT).append(&quot; *&quot;);</span>
                }
<span class="nc" id="L1554">            } catch (IOException ioe) {</span>
<span class="nc" id="L1555">                LOG.log(Level.SEVERE,</span>
                        &quot;Nothing to be done, should not happen&quot;,
                        ioe);
<span class="nc" id="L1558">            }</span>
<span class="nc" id="L1559">        }</span>

<span class="nc" id="L1561">        sDocComment.append(&quot;/&quot;).append(LINE_SEPARATOR);</span>

<span class="nc" id="L1563">        return sDocComment.toString();</span>
    }

    /**
     * Generates the code for a specific association
     * 
     * @param a The association
     * @param associationEnd an association end
     * @return a string containing the code for the &quot;from&quot; end of the
     *         association
     */
    private String generateAssociationFrom(Object a, Object associationEnd) {
        // TODO: does not handle n-ary associations
<span class="nc" id="L1576">        StringBuffer sb = new StringBuffer(80);</span>

<span class="nc" id="L1578">        Collection connections = Model.getFacade().getConnections(a);</span>
<span class="nc bnc" id="L1579" title="All 2 branches missed.">        for (Object associationEnd2 : connections) {</span>
<span class="nc bnc" id="L1580" title="All 2 branches missed.">            if (associationEnd2 != associationEnd) {</span>
<span class="nc" id="L1581">                sb.append(INDENT);</span>
<span class="nc" id="L1582">                sb.append(generateConstraintEnrichedDocComment(a,</span>
                        associationEnd2));
<span class="nc" id="L1584">                sb.append(generateAssociationEnd(associationEnd2));</span>
            }
<span class="nc" id="L1586">        }</span>

<span class="nc" id="L1588">        return sb.toString();</span>
    }

    /**
     * Generates the code for an association end
     * 
     * @param ae the association end
     * @return a String containing a reference to the association end
     */
    private String generateAssociationEnd(Object ae) {
<span class="nc bnc" id="L1598" title="All 2 branches missed.">        if (!Model.getFacade().isNavigable(ae)) {</span>
<span class="nc" id="L1599">            return &quot;&quot;;</span>
        }
<span class="nc bnc" id="L1601" title="All 2 branches missed.">        if (Model.getFacade().isAbstract(</span>
<span class="nc" id="L1602">                Model.getFacade().getAssociation(ae))) {</span>
<span class="nc" id="L1603">            return &quot;&quot;;</span>
        }
        // String s = INDENT + &quot;protected &quot;;
        // must be public or generate public navigation method!
        // String s = INDENT + &quot;public &quot;;
<span class="nc" id="L1608">        StringBuffer sb = new StringBuffer(80);</span>
<span class="nc" id="L1609">        sb.append(INDENT).append(generateCoreAssociationEnd(ae));</span>

<span class="nc" id="L1611">        return (sb.append(&quot;;&quot;).append(LINE_SEPARATOR)).toString();</span>
    }

    /**
     * Generates the code for an association end
     * @param ae  The association end.
     * @return  a string containing the code for an association end
     */
    String generateCoreAssociationEnd(Object ae) {
<span class="nc" id="L1620">        StringBuffer sb = new StringBuffer(80);</span>
<span class="nc" id="L1621">        sb.append(generateVisibility(Model.getFacade().getVisibility(ae)));</span>
        // sb.append(generateVisibility(ae));
<span class="nc bnc" id="L1623" title="All 2 branches missed.">        if (Model.getFacade().isStatic(ae)) {</span>
<span class="nc" id="L1624">            sb.append(&quot;static &quot;);</span>
        }
<span class="nc bnc" id="L1626" title="All 2 branches missed.">        if (Model.getFacade().isFrozen(ae)) {</span>
<span class="nc" id="L1627">            sb.append(&quot;final &quot;);</span>
        }
        // String n = ae.getName();
        // if (n != null &amp;&amp; !String.UNSPEC.equals(n))
        // s += generateName(n) + &quot; &quot;;
        // if (ae.isNavigable()) s += &quot;navigable &quot;;
        // if (ae.getIsOrdered()) s += &quot;ordered &quot;;
<span class="nc bnc" id="L1634" title="All 2 branches missed.">        if (Model.getFacade().getUpper(ae) == 1) {</span>
<span class="nc" id="L1635">            sb.append(generateClassifierRef(Model.getFacade().getType(ae)));</span>
        } else {
<span class="nc" id="L1637">            sb.append(&quot;List&quot;); // generateMultiplicity(m) + &quot; &quot;;</span>

            // create generic type for list
<span class="nc" id="L1640">            Object type = Model.getFacade().getType(ae);</span>
<span class="nc" id="L1641">            sb.append(String.format(&quot;&lt;%s&gt;&quot;, Model.getFacade().getName(type)));</span>
        }

<span class="nc" id="L1644">        sb.append(' ').append(generateAscEndName(ae));</span>

<span class="nc" id="L1646">        return sb.toString();</span>
    }

    // //////////////////////////////////////////////////////////////
    // internal methods?

    private String generateGeneralization(Collection generalizations) {
<span class="pc bpc" id="L1653" title="1 of 2 branches missed.">        if (generalizations == null) {</span>
<span class="nc" id="L1654">            return &quot;&quot;;</span>
        }
<span class="fc" id="L1656">        Collection classes = new ArrayList();</span>
<span class="pc bpc" id="L1657" title="1 of 2 branches missed.">        for (Object generalization : generalizations) {</span>
<span class="nc" id="L1658">            Object generalizableElement = Model.getFacade().getGeneral(</span>
                    generalization);
            // assert ge != null
<span class="nc bnc" id="L1661" title="All 2 branches missed.">            if (generalizableElement != null) {</span>
<span class="nc" id="L1662">                classes.add(generalizableElement);</span>
            }
<span class="nc" id="L1664">        }</span>
<span class="fc" id="L1665">        return generateClassList(classes);</span>
    }

    /**
     * Generates the code for a specification
     * (usually the classifier references).
     *
     * @param cls  the class object
     * @return  
     */
    private String generateSpecification(Object cls) {
<span class="fc" id="L1676">        Collection realizations = Model.getFacade().getSpecifications(cls);</span>
<span class="pc bpc" id="L1677" title="1 of 2 branches missed.">        if (realizations == null) {</span>
<span class="nc" id="L1678">            return &quot;&quot;;</span>
        }
<span class="fc" id="L1680">        LOG.fine(&quot;realizations: &quot; + realizations.size());</span>
<span class="fc" id="L1681">        StringBuffer sb = new StringBuffer(80);</span>
<span class="fc" id="L1682">        Iterator clsEnum = realizations.iterator();</span>
<span class="pc bpc" id="L1683" title="1 of 2 branches missed.">        while (clsEnum.hasNext()) {</span>
<span class="nc" id="L1684">            Object inter = clsEnum.next();</span>
<span class="nc" id="L1685">            sb.append(generateClassifierRef(inter));</span>
<span class="nc bnc" id="L1686" title="All 2 branches missed.">            if (clsEnum.hasNext()) {</span>
<span class="nc" id="L1687">                sb.append(&quot;, &quot;);</span>
            }
<span class="nc" id="L1689">        }</span>
<span class="fc" id="L1690">        return sb.toString();</span>
    }

    /**
     * Generates the class list
     * @param classifiers a collection of classifiers
     * @return a String containing the list of classifiers.
     */
    private String generateClassList(Collection classifiers) {
<span class="pc bpc" id="L1699" title="1 of 2 branches missed.">        if (classifiers == null) {</span>
<span class="nc" id="L1700">            return &quot;&quot;;</span>
        }
<span class="fc" id="L1702">        StringBuffer sb = new StringBuffer(80);</span>
<span class="fc" id="L1703">        Iterator clsEnum = classifiers.iterator();</span>
<span class="pc bpc" id="L1704" title="1 of 2 branches missed.">        while (clsEnum.hasNext()) {</span>
<span class="nc" id="L1705">            sb.append(generateClassifierRef(clsEnum.next()));</span>
<span class="nc bnc" id="L1706" title="All 2 branches missed.">            if (clsEnum.hasNext()) {</span>
<span class="nc" id="L1707">                sb.append(&quot;, &quot;);</span>
            }
        }
<span class="fc" id="L1710">        return sb.toString();</span>
    }

    /**
     * Returns a visibility String either for a VisibilityKind (according to the
     * definition in NotationProvider2), but also for a model element, because
     * if it is a Feature, then the tag 'src_visibility' is to be taken into
     * account for generating language dependent visibilities.
     * @param an object containing visibility data
     */
    private String generateVisibility(Object o) {
<span class="pc bpc" id="L1721" title="1 of 2 branches missed.">        if (Model.getFacade().isAFeature(o)) {</span>
            // TODO: The src_visibility tag doesn't appear to be created
            // anywhere by ArgoUML currently
<span class="nc" id="L1724">            Object tv = Model.getFacade().getTaggedValue(o, &quot;src_visibility&quot;);</span>
<span class="nc bnc" id="L1725" title="All 2 branches missed.">            if (tv != null) {</span>
<span class="nc" id="L1726">                String tagged = (String) Model.getFacade().getValue(tv);</span>
<span class="nc bnc" id="L1727" title="All 2 branches missed.">                if (tagged != null) {</span>
<span class="nc bnc" id="L1728" title="All 2 branches missed.">                    if (tagged.trim().equals(&quot;&quot;)</span>
<span class="nc bnc" id="L1729" title="All 2 branches missed.">                            || tagged.trim().toLowerCase().equals(&quot;package&quot;)</span>
<span class="nc bnc" id="L1730" title="All 2 branches missed.">                            || tagged.trim().toLowerCase().equals(&quot;default&quot;)) {</span>
<span class="nc" id="L1731">                        return &quot;&quot;;</span>
                    }
<span class="nc" id="L1733">                    return tagged + &quot; &quot;;</span>
                }
            }
        }

<span class="pc bpc" id="L1738" title="1 of 2 branches missed.">        if (Model.getFacade().isAModelElement(o)) {</span>
<span class="nc bnc" id="L1739" title="All 2 branches missed.">            if (Model.getFacade().isPublic(o)) {</span>
<span class="nc" id="L1740">                return &quot;public &quot;;</span>
            }
<span class="nc bnc" id="L1742" title="All 2 branches missed.">            if (Model.getFacade().isPrivate(o)) {</span>
<span class="nc" id="L1743">                return &quot;private &quot;;</span>
            }
<span class="nc bnc" id="L1745" title="All 2 branches missed.">            if (Model.getFacade().isProtected(o)) {</span>
<span class="nc" id="L1746">                return &quot;protected &quot;;</span>
            }
<span class="nc bnc" id="L1748" title="All 2 branches missed.">            if (Model.getFacade().isPackage(o)) {</span>
<span class="nc" id="L1749">                return &quot;&quot;;</span>
            }
        }
<span class="pc bpc" id="L1752" title="1 of 2 branches missed.">        if (Model.getFacade().isAVisibilityKind(o)) {</span>
<span class="fc bfc" id="L1753" title="All 2 branches covered.">            if (Model.getVisibilityKind().getPublic().equals(o)) {</span>
<span class="fc" id="L1754">                return &quot;public &quot;;</span>
            }
<span class="pc bpc" id="L1756" title="1 of 2 branches missed.">            if (Model.getVisibilityKind().getPrivate().equals(o)) {</span>
<span class="nc" id="L1757">                return &quot;private &quot;;</span>
            }
<span class="fc bfc" id="L1759" title="All 2 branches covered.">            if (Model.getVisibilityKind().getProtected().equals(o)) {</span>
<span class="fc" id="L1760">                return &quot;protected &quot;;</span>
            }
<span class="pc bpc" id="L1762" title="1 of 2 branches missed.">            if (Model.getVisibilityKind().getPackage().equals(o)) {</span>
<span class="fc" id="L1763">                return &quot;&quot;;</span>
            }
        }
<span class="nc" id="L1766">        return &quot;&quot;;</span>
    }

    private String generateScope(Object f) {
<span class="nc bnc" id="L1770" title="All 2 branches missed.">        if (Model.getFacade().isStatic(f)) {</span>
<span class="nc" id="L1771">            return &quot;static &quot;;</span>
        }
<span class="nc" id="L1773">        return &quot;&quot;;</span>
    }

    /**
     * Generate &quot;abstract&quot; keyword for an abstract operation.
     */
    private String generateAbstractness(Object op) {
<span class="nc bnc" id="L1780" title="All 2 branches missed.">        if (Model.getFacade().isAbstract(op)) {</span>
<span class="nc" id="L1781">            return &quot;abstract &quot;;</span>
        }
<span class="nc" id="L1783">        return &quot;&quot;;</span>
    }

    /**
     * Generate &quot;final&quot; keyword for final operations.
     * @param op the operation
     */
    private String generateChangeability(Object op) {
<span class="nc bnc" id="L1791" title="All 2 branches missed.">        if (Model.getFacade().isLeaf(op)) {</span>
<span class="nc" id="L1792">            return &quot;final &quot;;</span>
        }
<span class="nc" id="L1794">        return &quot;&quot;;</span>
    }

    /**
     * Generates the changeability for the object
     * @param sf indicates whether the object is read-only i.e. &quot;static final&quot;
     * @return a String containing the &quot;final&quot; keyword if necessary,
     *           an empty string otherwise
     */
    private String generateChangability(Object sf) {
<span class="nc bnc" id="L1804" title="All 2 branches missed.">        if (Model.getFacade().isReadOnly(sf)) {</span>
<span class="nc" id="L1805">            return &quot;final &quot;;</span>
        }
<span class="nc" id="L1807">        return &quot;&quot;;</span>
    }

    /**
     * Generates &quot;synchronized&quot; keyword for guarded operations.
     * 
     * @param op The operation
     * @return String The synchronized keyword if the operation is guarded, else
     *         &quot;&quot;.
     */
    private String generateConcurrency(Object op) {
<span class="nc bnc" id="L1818" title="All 2 branches missed.">        if (Model.getFacade().getConcurrency(op) != null</span>
<span class="nc" id="L1819">                &amp;&amp; Model.getConcurrencyKind().getGuarded()</span>
<span class="nc bnc" id="L1820" title="All 2 branches missed.">                        .equals(Model.getFacade().getConcurrency(op))) {</span>
<span class="nc" id="L1821">            return &quot;synchronized &quot;;</span>
        }
<span class="nc" id="L1823">        return &quot;&quot;;</span>
    }

    /**
     * Generates a String representation of a Multiplicity.
     * 
     * @param m the Multiplicity.
     * 
     * @return a human readable String.
     */
    private String generateMultiplicity(Object m) {
<span class="nc bnc" id="L1834" title="All 4 branches missed.">        if (m == null || &quot;1&quot;.equals(Model.getFacade().toString(m))) {</span>
<span class="nc" id="L1835">            return &quot;&quot;;</span>
        } else {
<span class="nc" id="L1837">            return Model.getFacade().toString(m);</span>
        }
    }

    private String generateState(Object m) {
<span class="nc" id="L1842">        return Model.getFacade().getName(m);</span>
    }


    private String generateTransition(Object m) {
<span class="nc" id="L1847">        StringBuffer sb = new StringBuffer(generateName(Model.getFacade()</span>
<span class="nc" id="L1848">                .getName(m)));</span>
<span class="nc" id="L1849">        String t = generateEvent(Model.getFacade().getTrigger(m));</span>
<span class="nc" id="L1850">        String g = generateGuard(Model.getFacade().getGuard(m));</span>
<span class="nc" id="L1851">        String e = generateAction(Model.getFacade().getEffect(m));</span>
<span class="nc bnc" id="L1852" title="All 2 branches missed.">        if (sb.length() &gt; 0) {</span>
<span class="nc" id="L1853">            sb.append(&quot;: &quot;);</span>
        }
<span class="nc" id="L1855">        sb.append(t);</span>
<span class="nc bnc" id="L1856" title="All 2 branches missed.">        if (g.length() &gt; 0) {</span>
<span class="nc" id="L1857">            sb.append(&quot; [&quot;).append(g).append(']');</span>
        }
<span class="nc bnc" id="L1859" title="All 2 branches missed.">        if (e.length() &gt; 0) {</span>
<span class="nc" id="L1860">            sb.append(&quot; / &quot;).append(e);</span>
        }
<span class="nc" id="L1862">        return sb.toString();</span>

    }

    private String generateAction(Object m) {
        // return m.getName();

<span class="nc bnc" id="L1869" title="All 2 branches missed.">        if (m != null) {</span>
<span class="nc" id="L1870">            Object script = Model.getFacade().getScript(m);</span>
<span class="nc bnc" id="L1871" title="All 2 branches missed.">            if ((script != null)</span>
<span class="nc bnc" id="L1872" title="All 2 branches missed.">                &amp;&amp; (Model.getFacade().getBody(script) != null)) {</span>

<span class="nc" id="L1874">                return Model.getFacade().getBody(script).toString();</span>

            }
        }
<span class="nc" id="L1878">        return &quot;&quot;;</span>
    }

    private String generateGuard(Object m) {
        // return generateExpression(Model.getFacade().getExpression(m));
<span class="nc bnc" id="L1883" title="All 4 branches missed.">        if (m != null &amp;&amp; Model.getFacade().getExpression(m) != null) {</span>
<span class="nc" id="L1884">            return generateExpression(Model.getFacade().getExpression(m));</span>
        }
<span class="nc" id="L1886">        return &quot;&quot;;</span>
    }

    private String generateMessage(Object m) {
<span class="nc bnc" id="L1890" title="All 2 branches missed.">        if (m == null) {</span>
<span class="nc" id="L1891">            return &quot;&quot;;</span>
        }
<span class="nc" id="L1893">        return generateName(Model.getFacade().getName(m)) + &quot;::&quot;</span>
<span class="nc" id="L1894">                + generateAction(Model.getFacade().getAction(m));</span>
    }

    /*
     * Generates the text for a (trigger) event.
     * 
     * @author MVW
     * 
     * @param m Object of any MEvent kind
     * 
     * @return The generated event (as a String).
     */
    private String generateEvent(Object m) {
<span class="nc bnc" id="L1907" title="All 2 branches missed.">        if (Model.getFacade().isAChangeEvent(m)) {</span>
<span class="nc" id="L1908">            return &quot;when(&quot;</span>
<span class="nc" id="L1909">                    + generateExpression(Model.getFacade().getExpression(m))</span>
                    + &quot;)&quot;;
        }
<span class="nc bnc" id="L1912" title="All 2 branches missed.">        if (Model.getFacade().isATimeEvent(m)) {</span>
<span class="nc" id="L1913">            return &quot;after(&quot;</span>
<span class="nc" id="L1914">                    + generateExpression(Model.getFacade().getExpression(m))</span>
                    + &quot;)&quot;;
        }
<span class="nc bnc" id="L1917" title="All 2 branches missed.">        if (Model.getFacade().isASignalEvent(m)) {</span>
<span class="nc" id="L1918">            return generateName(Model.getFacade().getName(m));</span>
        }
<span class="nc bnc" id="L1920" title="All 2 branches missed.">        if (Model.getFacade().isACallEvent(m)) {</span>
<span class="nc" id="L1921">            return generateName(Model.getFacade().getName(m));</span>
        }
<span class="nc" id="L1923">        return &quot;&quot;;</span>
    }

    /**
     * This method is responsible for generating the association end name. If
     * the association is named, then that name is returned. If the association
     * end is named, then that name is returned; otherwise the classifier name
     * is returned.s
     * 
     * @param ae The association
     * @return a string containing the name of the association end.
     */
    String generateAscEndName(Object ae) {
<span class="nc" id="L1936">        String n = Model.getFacade().getName(ae);</span>
<span class="nc" id="L1937">        Object asc = Model.getFacade().getAssociation(ae);</span>
<span class="nc" id="L1938">        String ascName = Model.getFacade().getName(asc);</span>
<span class="nc bnc" id="L1939" title="All 4 branches missed.">        if (n != null &amp;&amp; n.length() &gt; 0) {</span>
<span class="nc" id="L1940">            n = generateName(n);</span>
<span class="nc bnc" id="L1941" title="All 4 branches missed.">        } else if (ascName != null &amp;&amp; ascName.length() &gt; 0) {</span>
<span class="nc" id="L1942">            n = generateName(ascName);</span>
        } else {
<span class="nc" id="L1944">            n = generateClassifierRef(Model.getFacade().getType(ae));</span>
        }

<span class="nc" id="L1947">        n = String.valueOf(n.charAt(0)).toLowerCase() + n.substring(1);</span>

<span class="nc" id="L1949">        return n;</span>
    }

    /**
     * Gets the Java package name for a given namespace, ignoring the root
     * namespace (which is the model).
     * 
     * @param namespace the namespace
     * @return the Java package name
     */
    public String getPackageName(Object namespace) {
<span class="nc bnc" id="L1960" title="All 4 branches missed.">        if (namespace == null || !Model.getFacade().isANamespace(namespace)</span>
<span class="nc bnc" id="L1961" title="All 2 branches missed.">                || Model.getFacade().getNamespace(namespace) == null) {</span>
<span class="nc" id="L1962">            return &quot;&quot;;</span>
        }
<span class="nc" id="L1964">        String packagePath = Model.getFacade().getName(namespace);</span>
<span class="nc bnc" id="L1965" title="All 2 branches missed.">        if (packagePath == null) {</span>
<span class="nc" id="L1966">            return &quot;&quot;;</span>
        }
<span class="nc bnc" id="L1968" title="All 2 branches missed.">        while ((namespace = Model.getFacade().getNamespace(namespace))</span>
               != null) {
            // omit root package name; it's the model's root
<span class="nc bnc" id="L1971" title="All 2 branches missed.">            if (Model.getFacade().getNamespace(namespace) != null) {</span>
<span class="nc" id="L1972">                packagePath = Model.getFacade().getName(namespace) + '.'</span>
                        + packagePath;
            }
        }
<span class="nc" id="L1976">        return packagePath;</span>
    }

    /*
     * @see org.argouml.moduleloader.ModuleInterface#getName()
     */
    public String getName() {
<span class="nc" id="L1983">        return &quot;GeneratorJava&quot;;</span>
    }

    /*
     * @see org.argouml.moduleloader.ModuleInterface#getInfo(int)
     */
    public String getInfo(int type) {
<span class="nc bnc" id="L1990" title="All 5 branches missed.">        switch (type) {</span>
        case DESCRIPTION:
<span class="nc" id="L1992">            return &quot;Java notation and code generator&quot;;</span>
        case AUTHOR:
<span class="nc" id="L1994">            return JavaModuleGlobals.MODULE_AUTHOR;</span>
        case VERSION:
<span class="nc" id="L1996">            return JavaModuleGlobals.MODULE_VERSION;</span>
        case DOWNLOADSITE:
<span class="nc" id="L1998">            return JavaModuleGlobals.MODULE_DOWNLOADSITE;</span>
        default:
<span class="nc" id="L2000">            return null;</span>
        }
    }

    /*
     * Initialize the Java code generator.
     * 
     * @see org.argouml.moduleloader.ModuleInterface#enable()
     */
    public boolean enable() {
<span class="nc" id="L2010">        GeneratorManager.getInstance().addGenerator(java, this);</span>
<span class="nc" id="L2011">        return true;</span>
    }

    /*
     * Disable the Java code generator.
     * 
     * @see org.argouml.moduleloader.ModuleInterface#disable()
     */
    public boolean disable() {
<span class="nc" id="L2020">        GeneratorManager.getInstance().removeGenerator(java);</span>
<span class="nc" id="L2021">        return true;</span>
    }

    /**
     * Returns the _lfBeforeCurly.
     * 
     * @return boolean
     */
    public boolean isLfBeforeCurly() {
<span class="nc" id="L2030">        return lfBeforeCurly;</span>
    }

    /**
     * Returns the _verboseDocs.
     * 
     * @return boolean
     */
    public boolean isVerboseDocs() {
<span class="nc" id="L2039">        return verboseDocs;</span>
    }

    /**
     * Sets the lfBeforeCurly.
     * 
     * @param beforeCurl The new value.
     */
    public void setLfBeforeCurly(boolean beforeCurl) {
<span class="nc" id="L2048">        lfBeforeCurly = beforeCurl;</span>
<span class="nc" id="L2049">    }</span>

    /**
     * Sets the verboseDocs.
     * 
     * @param verbose The new value.
     */
    public void setVerboseDocs(boolean verbose) {
<span class="nc" id="L2057">        verboseDocs = verbose;</span>
<span class="nc" id="L2058">    }</span>

    private String generateActionState(Object actionState) {
<span class="nc" id="L2061">        String ret = &quot;&quot;;</span>
<span class="nc" id="L2062">        Object action = Model.getFacade().getEntry(actionState);</span>
<span class="nc bnc" id="L2063" title="All 2 branches missed.">        if (action != null) {</span>
<span class="nc" id="L2064">            Object expression = Model.getFacade().getScript(action);</span>
<span class="nc bnc" id="L2065" title="All 2 branches missed.">            if (expression != null) {</span>
<span class="nc" id="L2066">                ret = generateExpression(expression);</span>
            }
        }
<span class="nc" id="L2069">        return ret;</span>
    }

    private String generateExpression(Object expr) {
<span class="nc bnc" id="L2073" title="All 2 branches missed.">        if (Model.getFacade().isAExpression(expr)) {</span>
<span class="nc" id="L2074">            return generateUninterpreted((String) Model.getFacade().getBody(</span>
                    expr));
<span class="nc bnc" id="L2076" title="All 2 branches missed.">        } else if (Model.getFacade().isAConstraint(expr)) {</span>
<span class="nc" id="L2077">            return generateExpression(Model.getFacade().getBody(expr));</span>
        }
<span class="nc" id="L2079">        return &quot;&quot;;</span>
    }

    private String generateName(String n) {
<span class="fc" id="L2083">        return n;</span>
    }

    /**
     * Make a string non-null.
     * &lt;p&gt;
     * 
     * What is the purpose of this function? Shouldn't it be private static?
     * 
     * @param un The String.
     * @return a non-null string.
     */
    private String generateUninterpreted(String un) {
<span class="nc bnc" id="L2096" title="All 2 branches missed.">        if (un == null) {</span>
<span class="nc" id="L2097">            return &quot;&quot;;</span>
        }
<span class="nc" id="L2099">        return un;</span>
    }

    private String generateClassifierRef(Object cls) {
<span class="nc bnc" id="L2103" title="All 2 branches missed.">        if (cls == null) {</span>
<span class="nc" id="L2104">            return &quot;&quot;;</span>
        }
<span class="nc" id="L2106">        return Model.getFacade().getName(cls);</span>
    }

    private String generateStereotype(Object st) {
        /*
         * TODO: This code is not used. Why is it here? It causes an unwanted
         * dependency to the org.argouml.kernel. (Project,...)
         */
        // if (st == null)
        // return &quot;&quot;;
        // Project project =
        // ProjectManager.getManager().getCurrentProject();
        // ProjectSettings ps = project.getProjectSettings();
        // if (Model.getFacade().isAModelElement(st)) {
        // if (Model.getFacade().getName(st) == null)
        // return &quot;&quot;; // Patch by Jeremy Bennett
        // if (Model.getFacade().getName(st).length() == 0)
        // return &quot;&quot;;
        // return ps.getLeftGuillemot()
        // + generateName(Model.getFacade().getName(st))
        // + ps.getRightGuillemot();
        // }
        // if (st instanceof Collection) {
        // Object o;
        // StringBuffer sb = new StringBuffer(10);
        // boolean first = true;
        // Iterator iter = ((Collection) st).iterator();
        // while (iter.hasNext()) {
        // if (!first)
        // sb.append(',');
        // o = iter.next();
        // if (o != null) {
        // sb.append(generateName(Model.getFacade().getName(o)));
        // first = false;
        // }
        // }
        // if (!first) {
        // return ps.getLeftGuillemot()
        // + sb.toString()
        // + ps.getRightGuillemot();
        // }
        // }
<span class="nc" id="L2148">        return &quot;&quot;;</span>
    }

    /*
     * @see
     * org.argouml.uml.generator.CodeGenerator#generate(java.util.Collection,
     * boolean)
     */
    public Collection generate(Collection elements, boolean deps) {
<span class="nc" id="L2157">        LOG.fine(&quot;generate() called&quot;);</span>
<span class="nc" id="L2158">        File tmpdir = null;</span>
        try {
<span class="nc" id="L2160">            tmpdir = TempFileUtils.createTempDir();</span>
<span class="nc bnc" id="L2161" title="All 2 branches missed.">            if (tmpdir != null) {</span>
<span class="nc" id="L2162">                generateFiles(elements, tmpdir.getPath(), deps);</span>
<span class="nc" id="L2163">                return TempFileUtils.readAllFiles(tmpdir);</span>
            }
<span class="nc" id="L2165">            return Collections.EMPTY_LIST;</span>
        } finally {
<span class="nc bnc" id="L2167" title="All 2 branches missed.">            if (tmpdir != null) {</span>
<span class="nc" id="L2168">                TempFileUtils.deleteDir(tmpdir);</span>
            }
<span class="nc" id="L2170">            LOG.fine(&quot;generate() terminated&quot;);</span>
        }
    }

    /*
     * @see org.argouml.uml.generator.CodeGenerator#generateFiles(
     *         java.util.Collection, java.lang.String, boolean)
     */
    public Collection generateFiles(Collection elements, String path,
            boolean deps) {
<span class="nc" id="L2180">        LOG.fine(&quot;generateFiles() called&quot;);</span>
        // TODO: 'deps' is ignored here
<span class="nc bnc" id="L2182" title="All 2 branches missed.">        for (Object element : elements) {</span>
<span class="nc" id="L2183">            generateFile(element, path);</span>
<span class="nc" id="L2184">        }</span>
<span class="nc" id="L2185">        return TempFileUtils.readFileNames(new File(path));</span>
    }

    /*
     * @see org.argouml.uml.generator.CodeGenerator#generateFileList(
     *         java.util.Collection, boolean)
     */
    public Collection generateFileList(Collection elements, boolean deps) {
<span class="nc" id="L2193">        LOG.fine(&quot;generateFileList() called&quot;);</span>
        // TODO: 'deps' is ignored here
<span class="nc" id="L2195">        File tmpdir = null;</span>
        try {
<span class="nc" id="L2197">            tmpdir = TempFileUtils.createTempDir();</span>
<span class="nc bnc" id="L2198" title="All 2 branches missed.">            for (Object element : elements) {</span>
<span class="nc" id="L2199">                generateFile(element, tmpdir.getName());</span>
<span class="nc" id="L2200">            }</span>
<span class="nc" id="L2201">            return TempFileUtils.readFileNames(tmpdir);</span>
        } finally {
<span class="nc bnc" id="L2203" title="All 2 branches missed.">            if (tmpdir != null) {</span>
<span class="nc" id="L2204">                TempFileUtils.deleteDir(tmpdir);</span>
            }
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>